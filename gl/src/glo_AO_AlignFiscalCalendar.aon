rem ==========================================================================
rem --- glo_AO_AlignFiscalCalendar.aon 
rem --- AO_AlignFiscalCalendar class (AlignFiscalCalendar superclass)
rem --- GL superclass for re-aligning fiscal periods to facilitate comparative
rem --- financial reports.
rem --- 
rem --- AddonSoftware Version 17.0
rem --- Copyright BASIS International Ltd.  All Rights Reserved.
rem ==========================================================================

rem /**
rem  * This class provides for re-aligning periods in a fiscal year to facilitate
rem  * comparative financial reports with a different "base" fiscal year.
rem  */

    use ::bbtranslator.bbj::BBTranslator
    use java.util.GregorianCalendar

    class public AO_AlignFiscalCalendar
        field protected BBjNumber adjustFebruary
        field protected BBjVector baseFiscalCalPerEnding! = BBjAPI().makeVector()
        field protected BBjString baseFiscalCalStartDate$
        field protected BBjString baseFiscalCalTotalPers$
        field protected BBjString baseFiscalYear$
        field protected GregorianCalendar Calendar! = new GregorianCalendar()
        field protected BBjNumber devGlmAcctSumHdr = -1
        field protected BBjNumber devGlmAcctSummary = -1
        field protected BBjNumber devGlsCalendar = -1
        field protected BBjNumber devGltTransDetail = -1
        field protected BBjNumber devGltTransDetail2 = -1
        field protected BBjNumber devGlwAcctSummary = -1
        field protected BBjString firmID$
        field protected BBjString priorFiscalYearClosed$
        field protected BBjString retainedEarningsAccount$
        field protected BBjString tplGlmAcctSumHdr$
        field protected BBjString tplGlmAcctSummary$
        field protected BBjString tplGlsCalendar$
        field protected BBjString tplGltTransDetail$
        field protected BBjString tplGlwAcctSummary$
        field protected BBTranslator Translate!
        field protected BBjString unitsFlag$

        rem /**
        rem  * Constructor.
        rem  *
        rem  * @param BBjString firmId$
        rem  */
        method public AO_AlignFiscalCalendar(BBjString firmID$)
            seterr AlignFiscalCalendar_error

            rem --- Open gls_earnings
            filename$ = "gls_earnings"
            devGlsEarnings = unt
            open(devGlsEarnings)stbl("+GLDATA")+filename$

            rem --- Get record template for gls_earnings
            tplsChan = unt
            open(tplsChan)stbl("+DIR_BRD")+"ddm_table_tpls.dat"
            read(tplsChan,key=cvs(pad(filename$,16," "),4),dom=*next)*,*,table_tpl$
            tplGlsEarnings$ = table_tpl$
            dim gls_earnings$:tplGlsEarnings$

            rem --- Open gls_params
            filename$ = "gls_params"
            devGlsParams = unt
            open(devGlsParams)stbl("+GLDATA")+filename$

            rem --- Get record template for gls_params
            read(tplsChan,key=cvs(pad(filename$,16," "),4),dom=*next)*,*,table_tpl$
            tplGlsParams$ = table_tpl$
            dim gls_params$:tplGlsParams$

            rem --- Open gls_calendar
            filename$ = "gls_calendar"
            devGlsCalendar = unt
            open(devGlsCalendar)stbl("+GLDATA")+filename$

            rem --- Get record template for gls_calendar
            read(tplsChan,key=cvs(pad(filename$,16," "),4),dom=*next)*,*,table_tpl$
            tplGlsCalendar$ = table_tpl$
            dim gls_calendar$:tplGlsCalendar$
            
            rem --- Get gls_earnings GL01 record for firmId$
            readrecord(devGlsEarnings,key=firmID$+"GL01",dom=*next)gls_earnings$
            
            rem --- Get gls_params GL00 record for firmId$
            readrecord(devGlsParams,key=firmID$+"GL00")gls_params$
            
            rem --- Initialize field variables
            #adjustFebruary = gls_params.adjust_february
            #firmID$ = firmID$
            #devGlsCalendar = devGlsCalendar
            #priorFiscalYearClosed$ = gls_params.gl_yr_closed$
            #retainedEarningsAccount$ = gls_earnings.gl_account$
            #tplGlsCalendar$ = tplGlsCalendar$
            #unitsFlag$ = gls_params.units_flag$
            #setBaseFiscalYear(gls_params.current_year$)

            rem --- Initialize BBTranslator Translate! object
            rdTransSpaceKey$=stbl("+PROPS_NAME")+"_"+stbl("+USER_LOCALE")+"_BBTranslator"
            #Translate!=cast(BBTranslator,BBjAPI().getGroupNamespace().getValue(rdTransSpaceKey$,err=*next))
            if #Translate!=null()
                #Translate!=BBTranslator.getInstance(stbl("+PROPS_NAME"),stbl("+USER_LOCALE"),null(),stbl("+PROPS_PATH"))
                BBjAPI().getGroupNamespace().setValue(rdTransSpaceKey$,#Translate!)
            endif

            rem --- Close files
            close(tplsChan,err=*next)
            close(devGlsParams,err=*next)

            methodret
            
AlignFiscalCalendar_error:rem --- Method error trap/handler
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Updates glw_acctsummary using transactions from glt_transdetail for the selected fiscal year.
        rem  *
        rem  * Returns trip read key for glw_acctsummary (#firmID$ + thisYear$ + #baseFiscalYear$).
        rem  * Note: tripKey$ will be blank if an error is encountered.
        rem  *
        rem  * @param BBjString thisYear$
        rem  *
        rem  * @return BBjString tripKey$
        rem  */
        method public BBjString alignCalendar(BBjString thisYear$)
            seterr alignCalendar_error
            tripKey$=""
            
            rem --- Open necessary files, and verify success
            #openWorkFiles()
            if #devGlwAcctSummary>0 and #devGltTransDetail>0 and #devGlwAcctSummary>0 then

                rem --- Always update glw_acctsummary if (1) the selected year is the next fiscal year, or (2) the selected year 
                rem --- is the prior fiscal year and it has not been closed or shares dates with the current fiscal year.
                update_glwAcctsummary=0
                if num(thisYear$)=num(#baseFiscalYear$)+1 then update_glwAcctsummary=1
                if num(thisYear$)=num(#baseFiscalYear$)-1 then
                    if #priorFiscalYearClosed$<>"Y" then
                        update_glwAcctsummary=1
                    else
                        rem --- Does the last day of the aligned prior fiscal year and the first day of the current fiscal year overlap?
                        lastPeriod=num(#baseFiscalCalTotalPers$)
                        fiscalYear=num(#baseFiscalYear$)
                        call stbl("+DIR_PGM")+"adc_perioddates.aon",lastPeriod,fiscalYear,begdate$,enddate$,table_chans$[all],status
                        if status then methodret ""
                        delta=num(enddate$(1,4))-fiscalYear
                        alignedFiscalCalEndDate$=str(num(thisYear$)+delta:"0000")+enddate$(5)
                        currentFiscalCalStartDate$=#baseFiscalYear$+#baseFiscalCalStartDate$
                        if alignedFiscalCalEndDate$>=currentFiscalCalStartDate$ then
                            update_glwAcctsummary=1
                        endif
                    endif
                endif
                if update_glwAcctsummary then
                    rem --- Remove existing glw_acctsummary records for thisYear$ so that it will get aligned with 
                    rem --- current glt_transdetail (glt-06) data.
                    rec_pfx$=#firmID$+thisYear$+#baseFiscalYear$
                    call stbl("+DIR_PGM")+"adc_clearpartial.aon","N",#devGlwAcctSummary,rec_pfx$,status
                    if status then methodret ""
                endif

                rem --- Done if glw_acctsummary already has the aligned calendar.
                testKey$=#firmID$+thisYear$+#baseFiscalYear$
                read(#devGlwAcctSummary,key=testKey$,dom=*next)
                glwAcctSummary_key$=key(#devGlwAcctSummary,end=*next)
                if pos(testKey$=glwAcctSummary_key$)<>1 then

                    rem --- Start progress meter
                    milestone=10
                    milestone=num(stbl("+MILESTONE",err=*next),err=*next)
                    total_recs=0
                    meter_text$=#Translate!.getTranslation("AON_ALIGNING_PERIODS","Aligning Fiscal Periods")
                    call stbl("+DIR_PGM")+"adc_progress.aon","NC","GLT_TRANSDETAIL",meter_text$,"","",0,#devGltTransDetail,10,meter_num,status

                    rem --- If the current fiscal year ends in a different calendar year than it started,
                    rem --- apply that same delta to thisYear$ to get the year it ends in.
                    lastPeriod=num(#baseFiscalCalTotalPers$)
                    fiscalYear=num(#baseFiscalYear$)
                    call stbl("+DIR_PGM")+"adc_perioddates.aon",lastPeriod,fiscalYear,begdate$,enddate$,table_chans$[all],status
                    if status then methodret ""
                    delta=num(enddate$(1,4))-fiscalYear
                    newFiscalCalEndDate$=str(num(thisYear$)+delta:"0000")+enddate$(5)

                    rem --- Build glw_acctsummary records from glt_transdetail transactions
                    newFiscalCalStartDate$=thisYear$+#baseFiscalCalStartDate$
                    read(#devGltTransDetail,key=#firmID$+newFiscalCalStartDate$,knum="BY_TRANS_DATE",dom=*next)
                    while 1
                        rem --- Increment progress meter
                        total_recs=total_recs+1
                        if mod(total_recs,milestone)=0 then call stbl("+DIR_PGM")+"adc_progress.aon","S","","","","",0,0,milestone,meter_num,status

                        dim gltTransDetail$:#tplGltTransDetail$
                        readrecord(#devGltTransDetail,end=*break)gltTransDetail$
                        if gltTransDetail.firm_id$<>#firmID$ then break
                        if gltTransDetail.trns_date$>newFiscalCalEndDate$ then break

                        rem --- Get "aligned period" for this transaction
                        period=#getAlignedPeriod(gltTransDetail.trns_date$)
                        
                        rem --- Update/write glw_acctsummary record
                        success=0
                        #updateAcctSummary(gltTransDetail$, thisYear$, period,err=*next); success=1
                        if !success then
                            err_num=err
                            if err_num=901 then
                                methodret ""
                            else
                                goto alignCalendar_error
                            endif
                        endif
                    wend

                    rem --- Stop progress meter
                    call stbl("+DIR_PGM")+"adc_progress.aon","D","","","","",0,0,0,0,status
                endif
                tripKey$=#firmID$+thisYear$+#baseFiscalYear$
            endif

            methodret tripKey$
             
alignCalendar_error:rem --- Method error trap/handler
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Checks if the fiscal calendar for thisYear$ is the same as the calendar for the current
        rem  * fiscal year. Returns true if the calendars are different and can be aligned. Returns false
        rem  * if the calendars are the same and cannot be aligned.
        rem  * 
        rem  * Returns GoldMine contact information for the given GoldMine account number and record id.
        rem  *
        rem  * @param BBjString thisYear$
        rem  *
        rem  * @return boolean true (can be aligned) or false (cannot be aligned)
        rem  */
        method public boolean canAlignCalendar(BBjString thisYear$)
            seterr canAlignCalendar_error
            canAlign = 0

            rem --- Get fiscal calendar for thisYear$
            dim thisCalendar$:#tplGlsCalendar$
            readrecord(#devGlsCalendar,key=#firmID$+thisYear$,dom=*next)thisCalendar$
            if thisCalendar.firm_id$<>#firmID$ or thisCalendar.year$<>thisYear$ then
                methodret Boolean.valueOf("false")
            endif

            rem --- Get fiscal calendar for current fiscal year
            dim currFiscalCalendar$:#tplGlsCalendar$
            readrecord(#devGlsCalendar,key=#firmID$+#baseFiscalYear$)currFiscalCalendar$

            rem --- Can the fiscal calendars be aligned (i.e. they are different)?
            if thisCalendar.total_pers$ <> currFiscalCalendar.total_pers$ then
                canAlign = 1
            else
                if thisCalendar.cal_start_date$ <> currFiscalCalendar.cal_start_date$ then
                    canAlign = 1
                else
                    for per=1 to num(thisCalendar.total_pers$)
                        if field(thisCalendar$,"PER_ENDING_"+str(per:"00")) <> field(currFiscalCalendar$,"PER_ENDING_"+str(per:"00")) then
                            canAlign = 1

                            rem --- Adjust last day of February for leap year
                            mmdd$=field(currFiscalCalendar$,"PER_ENDING_"+str(per:"00"))
                            mm$=mmdd$(1,2)
                            if mm$="02" then
                                dd$=mmdd$(3)
                                if dd$="28" then
                                    if #adjustFebruary and #Calendar!.isLeapYear(num(thisYear$)) then dd$="29"
                                else
                                    if dd$="29" and !#Calendar!.isLeapYear(num(thisYear$)) then dd$="28"
                                endif
                                if field(thisCalendar$,"PER_ENDING_"+str(per:"00")) = mm$+dd$ then
                                    canAlign = 0
                                endif
                            endif

                            if canAlign then break
                        endif
                    next per
                endif
            endif

            if canAlign then
                methodret Boolean.valueOf("true")
            else
                methodret Boolean.valueOf("false")
            endif
             
canAlignCalendar_error:rem --- Method error trap/handler
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Determines the fiscal period a transaction occurs in ignoring the year and using the 
        rem  * calendar for the current fiscal year.
        rem  * 
        rem  * @param BBjString transDate$
        rem  *
        rem  * @return BBjNumber period
        rem  */
        method protected BBjNumber getAlignedPeriod(BBjString transDate$)
            seterr getAlignedPeriod_error
            yyyy$=transDate$(1,4)
            mm$=transDate$(5,2)
            dd$=transDate$(7)
            totalPers=num(#baseFiscalCalTotalPers$)

            period=totalPers
            for i=0 to totalPers-1
                rem --- Adjust last day of February for leap year
                if mm$="02" then
                    if dd$="28" then
                        if #adjustFebruary and #Calendar!.isLeapYear(num(yyyy$)) then dd$="29"
                    else
                        if dd$="29" and !#Calendar!.isLeapYear(num(yyyy$)) then dd$="28"
                    endif
                endif

                rem --- Is date after this period?
                if mm$+dd$>#baseFiscalCalPerEnding!.getItem(i) then continue
                period=i+1
                break
            next i

            methodret period
             
getAlignedPeriod_error:rem --- Method error trap/handler
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Set fiscal calendar data for the given base fiscal year.
        rem  *
        rem  * @param BBjString baseYear$
        rem  */
        method public void setBaseFiscalYear(BBjString baseYear$)
            seterr setBaseFiscalYear_error

            rem --- Get gls_calendar record for baseYear$
            dim glsCalendar$:#tplGlsCalendar$
            readrecord(#devGlsCalendar,key=#firmID$+baseYear$)glsCalendar$
            
            rem --- Initialize field variables
            #baseFiscalYear$ = baseYear$
            #baseFiscalCalStartDate$ = glsCalendar.cal_start_date$
            #baseFiscalCalTotalPers$ = glsCalendar.total_pers$
            for per=1 to num(#baseFiscalCalTotalPers$)
                #baseFiscalCalPerEnding!.addItem(field(glsCalendar$,"PER_ENDING_"+str(per:"00")))
            next per

            methodret
            
setBaseFiscalYear_error:rem --- Method error trap/handler
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Sum glt_transdetail trans_amt and units for the given GL account from the start date to
        rem  * (not through) the end date.
        rem  *
        rem  * @param BBjString glAccoutn$
        rem  * @param BBjString startDate$
        rem  * @param BBjString endDate$
        rem  *
        rem  * @return BBjVector! sumVect!.get(0) = sum of transaction amounts
        rem  *                    sumVect!.get(1) = sum of units
        rem  */
        method protected BBjVector sumGltTransactions(BBjString glAccount$,BBjString startDate$,BBjString endDate$)
            seterr sumGltTransactions_error
            sumVect!=BBjAPI().makeVector()
            beginAmt=0
            beginUnits=0

            dim transDetail2$:#tplGltTransDetail$
            read(#devGltTransDetail2,key=#firmID$+startDate$,knum="BY_TRANS_DATE",dom=*next)
            while 1
                readrecord(#devGltTransDetail2,end=*break)transDetail2$
                if transDetail2.firm_id$<>#firmID$ then break
                if transDetail2.trns_date$>endDate$ then break
                if transDetail2.gl_account$<>glAccount$ then continue
                beginAmt=beginAmt+transDetail2.trans_amt
                beginUnits=beginUnits+transDetail2.units
            wend
            sumVect!.addItem(beginAmt)
            sumVect!.addItem(beginUnits)

            methodret sumVect!
            
sumGltTransactions_error:rem --- Method error trap/handler
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Updates/writes glw_acctsummary period_amt (and period_units) for the given glt_transdetail 
        rem  * record using the given period and year. 
        rem  * 
        rem  * @param BBjString gltTransDetail$
        rem  * @param BBjString thisYear$
        rem  * @param BBjNumber period
        rem  */
        method protected void updateAcctSummary(BBjString gltTransDetail$, BBjString thisYear$, BBjNumber period)
            seterr updateAcctSummary_error
            dim glt06$:#tplGltTransDetail$
            glt06$=gltTransDetail$

            dim glwAcctSummary$:#tplGlwAcctSummary$
            findrecord(#devGlwAcctSummary,key=glt06.firm_id$+thisYear$+#baseFiscalYear$+glt06.gl_account$,dom=*next)glwAcctSummary$
            if glwAcctSummary.firm_id$<>glt06.firm_id$ then
                rem --- Initialize new glw_acctsummary record
                glwAcctSummary.firm_id$=glt06.firm_id$
                glwAcctSummary.year$=thisYear$
                glwAcctSummary.gl_year$=#baseFiscalYear$
                glwAcctSummary.gl_account$=glt06.gl_account$
                glwAcctSummary.begin_amt=0
                glwAcctSummary.begin_units=0
                for per=1 to 13
                    field glwAcctSummary$,"PERIOD_AMT_"+str(per:"00")=0
                    field glwAcctSummary$,"PERIOD_UNITS_"+str(per:"00")=0
                next per

                rem --- If available, use existing glm_acctsummary data to initialize begin_amt and begin_units
                recordId$=$FF$
                if thisYear$=#baseFiscalYear$ then recordId$="0"; rem --- current year actual
                if num(thisYear$)=num(#baseFiscalYear$)-1 then recordId$="2"; rem --- prior year actual
                if num(thisYear$)=num(#baseFiscalYear$)+1 then recordId$="4"; rem --- next year actual
                dim glmAcctSummary$:#tplGlmAcctSummary$
                findrecord(#devGlmAcctSummary,key=glwAcctSummary.firm_id$+glwAcctSummary.gl_account$+recordId$,dom=*next)glmAcctSummary$
                if glmAcctSummary.firm_id$=glwAcctSummary.firm_id$ then
                    begin_amt=glmAcctSummary.begin_amt
                    begin_units=glmAcctSummary.begin_units

                    rem --- When initializing glwAcctSummary for retained earnings account, use balance if record already exits.
                    if glwAcctSummary.gl_account$=#retainedEarningsAccount$ then
                        dim retainedEarnings_glwAcctSummary$:#tplGlwAcctSummary$
                        retainedEarings_key$=glwAcctSummary.firm_id$+glwAcctSummary.year$+glwAcctSummary.gl_year$+#retainedEarningsAccount$
                        findrecord(#devGlwAcctSummary,key=retainedEarings_key$,dom=*next)retainedEarnings_glwAcctSummary$
                        begin_amt=retainedEarnings_glwAcctSummary.begin_amt+glmAcctSummary.begin_amt
                        begin_units=retainedEarnings_glwAcctSummary.begin_units+glmAcctSummary.begin_units
                    endif

                    rem --- If this cal_start_date is not the same as the base cal_start_date, then adjust begin_amt and begin_units
                    dim glsCalendar$:#tplGlsCalendar$ 
                    readrecord(#devGlsCalendar,key=glmAcctSummary.firm_id$+thisYear$)glsCalendar$
                    if glsCalendar.cal_start_date$<>#baseFiscalCalStartDate$ then

                        rem --- If this cal_start_date is later than base cal_start_date, then subtract transactions in that date range.
                        if glsCalendar.cal_start_date$>#baseFiscalCalStartDate$ then
                            startDate$=thisYear$+#baseFiscalCalStartDate$
                            endDate$=thisYear$+glsCalendar.cal_start_date$

                            adjustVect!=#sumGltTransactions(glwAcctSummary.gl_account$,startDate$,endDate$)
                            
                            begin_amt=begin_amt-adjustVect!.get(0)
                            begin_units=begin_units-adjustVect!.get(1)
                        endif

                        rem --- If this cal_start_date is earlier than base cal_start_date, then add transactions in that date range.
                        if glsCalendar.cal_start_date$<#baseFiscalCalStartDate$ then
                            rem --- Cannot change calendar year fiscal year starts in when aliging fiscal periods.
                            if glsCalendar.cal_start_date$(1,2)<>#baseFiscalCalStartDate$(1,2) then
                                rem --- The month the fiscal year starts in is being changed.
                                call stbl("+DIR_PGM")+"adc_perioddates.aon",1,num(thisYear$),begdate$,enddate$,table_chans$[all],status
                                if status or enddate$(5)<#baseFiscalCalStartDate$ then
                                    rem --- The new fiscal year start month is after the un-aligned first period end date,
                                    rem --- so it must be in a different calendar year.
                                    throw "updateAcctSummary: Cannot change calendar year fiscal year starts.",901
                                endif
                            endif

                            startDate$=thisYear$+glsCalendar.cal_start_date$
                            endDate$=thisYear$+#baseFiscalCalStartDate$
                            
                            adjustVect!=#sumGltTransactions(glwAcctSummary.gl_account$,startDate$,endDate$)
                            
                            begin_amt=begin_amt+adjustVect!.get(0)
                            begin_units=begin_units+adjustVect!.get(1)
                        endif

                        rem --- Post adjustments for income and expense accounts to the retained earnings account balance,
                        rem --- and set income and expense account balances to zero.
                        dim glmAcctSumHdr$:#tplGlmAcctSumHdr$
                        findrecord(#devGlmAcctSumHdr,key=glwAcctSummary.firm_id$+glwAcctSummary.gl_account$,dom=*next)glmAcctSumHdr$
                        if pos(glmAcctSumHdr.gl_acct_type$="ALC")=0 or glmAcctSumHdr.gl_account$=#retainedEarningsAccount$ then
                            rem --- Post adjustments for income and expense accounts to the retained earnings account balance.
                            dim retainedEarnings_glwAcctSummary$:#tplGlwAcctSummary$
                            retainedEarnings_glwAcctSummary.firm_id$=glwAcctSummary.firm_id$
                            retainedEarnings_glwAcctSummary.year$=glwAcctSummary.year$
                            retainedEarnings_glwAcctSummary.gl_year$=glwAcctSummary.gl_year$
                            retainedEarnings_glwAcctSummary.gl_account$=#retainedEarningsAccount$
                            retainedEarnings_key$=glwAcctSummary.firm_id$+glwAcctSummary.year$+glwAcctSummary.gl_year$+#retainedEarningsAccount$
                            findrecord(#devGlwAcctSummary,key=retainedEarnings_key$,dom=*next)retainedEarnings_glwAcctSummary$
                            retainedEarnings_glwAcctSummary.begin_amt=retainedEarnings_glwAcctSummary.begin_amt+begin_amt
                            if #unitsFlag$="Y" then retainedEarnings_glwAcctSummary.begin_units=retainedEarnings_glwAcctSummary.begin_units+begin_units
                            writerecord(#devGlwAcctSummary)retainedEarnings_glwAcctSummary$

                            rem --- Set income and expense account balances to zero.
                            begin_amt=0
                            begin_units=0
                        endif
                    endif

                    glwAcctSummary.begin_amt=begin_amt
                    if #unitsFlag$="Y" then glwAcctSummary.begin_units=begin_units
                else
                    rem --- What should we do if/when glm_acctsummary data isn't available?
                    rem --- ER 8492 D6 will insure glm_acctsummary data exists for all fiscal calendars with existing glt_transdetail (glt-06) data.

                    rem --- Handle case where there is no glt_transdetail (glt-06) data to create glm_acctsummary records
                    glwAcctSummary.begin_amt=0
                    if #unitsFlag$="Y" then glwAcctSummary.begin_units=0
                endif
            endif

            rem --- Update and write glw_acctsummary record
            field glwAcctSummary$,"PERIOD_AMT_"+str(period:"00")=nfield(glwAcctSummary$,"PERIOD_AMT_"+str(period:"00"))+glt06.trans_amt
            if #unitsFlag$="Y" then
                field glwAcctSummary$,"PERIOD_UNITS_"+str(period:"00")=nfield(glwAcctSummary$,"PERIOD_UNITS_"+str(period:"00"))+glt06.units
            endif
            writerecord(#devGlwAcctSummary)glwAcctSummary$

            methodret
            
updateAcctSummary_error:rem --- Method error trap/handler
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Open files and get templates for all tables needed to align fiscal calendars.
        rem  *
        rem  * Note: #devGlwAcctSummary, #devGlwAcctSummary, #devGltTransDetail and/or #devGlwAcctSummary
        rem  * will be less than zero if an error is encounterd.
        rem  */
        method protected void openWorkFiles()
            seterr openWorkFiles_error

            rem --- Open glm_acctsummary
            if #devGlmAcctSumHdr < 0 then
                rem --- Open glm_acctsumhdr and get record template. Create file if necessary.
                num_files=1
                dim open_tables$[1:num_files],open_opts$[1:num_files],open_chans$[1:num_files],open_tpls$[1:num_files]
                open_tables$[1]="GLM_ACCTSUMHDR",open_opts$[1]="OTA[1]"

                call stbl("+DIR_SYP")+"bac_open_tables.bbj",open_beg,open_end,open_tables$[all],open_opts$[all],open_chans$[all],open_tpls$[all],rd_table_chans$[all],open_batch,open_status$

                if open_status$ = "" then
                    rem --- Hold on to channel and record template for glw_acctsummary
                    #devGlmAcctSumHdr = num(open_chans$[1])
                    #tplGlmAcctSumHdr$ = open_tpls$[1]
                endif
            endif

            rem --- Open glm_acctsummary
            if #devGlmAcctSummary < 0 then
                rem --- Open glm_acctsummary and get record template. Create file if necessary.
                num_files=1
                dim open_tables$[1:num_files],open_opts$[1:num_files],open_chans$[1:num_files],open_tpls$[1:num_files]
                open_tables$[1]="GLM_ACCTSUMMARY",open_opts$[1]="OTA[1]"

                call stbl("+DIR_SYP")+"bac_open_tables.bbj",open_beg,open_end,open_tables$[all],open_opts$[all],open_chans$[all],open_tpls$[all],rd_table_chans$[all],open_batch,open_status$

                if open_status$ = "" then
                    rem --- Hold on to channel and record template for glw_acctsummary
                    #devGlmAcctSummary = num(open_chans$[1])
                    #tplGlmAcctSummary$ = open_tpls$[1]
                endif
            endif

            rem --- Open glt_transdetail
            if #devGltTransDetail < 0 then
                rem --- Open glt_transdetail and get record template. Create file if necessary.
                num_files=2
                dim open_tables$[1:num_files],open_opts$[1:num_files],open_chans$[1:num_files],open_tpls$[1:num_files]
                open_tables$[1]="GLT_TRANSDETAIL",open_opts$[1]="OTA[1]"
                open_tables$[2]="GLT_TRANSDETAIL",open_opts$[2]="OTA[2]"

                call stbl("+DIR_SYP")+"bac_open_tables.bbj",open_beg,open_end,open_tables$[all],open_opts$[all],open_chans$[all],open_tpls$[all],rd_table_chans$[all],open_batch,open_status$

                if open_status$ = "" then
                    rem --- Hold on to channel and record template for glt_transdetail
                    #devGltTransDetail = num(open_chans$[1])
                    #devGltTransDetail2 = num(open_chans$[2])
                    #tplGltTransDetail$ = open_tpls$[1]
                endif
            endif

            rem --- Open glw_acctsummary
            if #devGlwAcctSummary < 0 then
                rem --- Open glw_acctsummary and get record template. Create file if necessary.
                num_files=1
                dim open_tables$[1:num_files],open_opts$[1:num_files],open_chans$[1:num_files],open_tpls$[1:num_files]
                open_tables$[1]="GLW_ACCTSUMMARY",open_opts$[1]="OTA[1]"

                call stbl("+DIR_SYP")+"bac_open_tables.bbj",open_beg,open_end,open_tables$[all],open_opts$[all],open_chans$[all],open_tpls$[all],rd_table_chans$[all],open_batch,open_status$

                if open_status$ = "" then
                    rem --- Hold on to channel and record template for glw_acctsummary
                    #devGlwAcctSummary = num(open_chans$[1])
                    #tplGlwAcctSummary$ = open_tpls$[1]
                endif
            endif

            methodret
            
openWorkFiles_error:rem --- Method error trap/handler
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Close all open channels and connections.
        rem  */
        method public void close()
            seterr close_error

            if #devGlmAcctSumHdr > 0 then close(#devGlmAcctSumHdr,err=*next)
            if #devGlmAcctSummary > 0 then close(#devGlmAcctSummary,err=*next)
            if #devGlsCalendar > 0 then close(#devGlsCalendar,err=*next)
            if #devGltTransDetail > 0 then close(#devGltTransDetail,err=*next)
            if #devGltTransDetail2 > 0 then close(#devGltTransDetail2,err=*next)
            if #devGlwAcctSummary > 0 then close(#devGlwAcctSummary,err=*next)

            methodret
            
close_error:rem --- Method error trap/handler
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Cleanup on object's destruction and garbage collection.
        rem  */
        method protected void finalize()

            rem --- Close all open channels and connections
            #close()

            methodret
        methodend
	
classend
