rem --- Purchase Order Invoice Entry Register Update
rem --- Program pou_invreg v8.0.0 23Jun2009 (pou_ea)
rem --- Created by adx_codeport.bbj v1.1.5 (06/23/2009 05:58:36)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright (c) 1981-2007 AddonSoftware
rem --- All Rights Reserved

rem --- The following IOLIST's were removed from this program:

rem --- apm01a: iolist h0$(1),h1$(1)
rem --- apm02a: iolist u0$(1),u1$(1),u2$(1),u[all]
rem --- apm10b: iolist x0$(1),x1$(1)
rem --- apt01a: iolist h0$(1),h[all]
rem --- apt02a: iolist t0$(1),t[all]
rem --- apt03a: iolist xa$(24)
rem --- apt03b: iolist xb$(31)
rem --- apt03c: iolist xc$(21)
rem --- apt11a: iolist l0$(1),l1$(1),l[all]
rem --- arm10d: iolist z0$(1),z1$(1)
rem --- ivm01a: iolist s0$(1),s1$(1),s2$(1),s3$(1),s4$(1),s5$,s6$(1),s[all]
rem --- ivm02a: iolist u0$(1),u1$(1),u2$,u[all]
rem --- poe05a: iolist a0$(1),a1$(1),a2$,a3$,a[all]
rem --- poe12a: iolist l0$(1),l1$(1),l2$(1),l3$(1),l4$(1),l5$,l6$,l[all]
rem --- poe15a: iolist b0$(1),b1$(1),b2$,b[all]
rem --- poe25a: iolist c0$(1),c1$(1),c2$,c[all]
rem --- poe35a: iolist d0$(1),d1$(1),d[all]; rem escape ,job$(1)
rem --- pom02a: iolist y0$(1),y1$(1),y2$(1)
rem --- pot05a: iolist ha$(1),a1$(1),a2$,a3$,a[all]
rem --- pot14a: iolist w0$(1),w1$(1),w2$(1),w3$(1),w4$(1),w5$,w6$,w[all]
rem --- pot15a: iolist hb$(1),b1$(1),b2$,b[all]
rem --- pot25a: iolist hc$(1),c1$(1),c2$,c[all]
rem --- pot35a: iolist hd$(1)
rem --- pow17a: iolist u0$(1),u[all]
rem --- sfe01a: iolist woe01$(1)
rem --- sfm10a: iolist *,wom10$(1)


    seterr std_error
    setesc std_error

rem --- Retrieve the program path

    pgmdir$=stbl("+DIR_PGM",err=*next)

rem --- Retrieve sysinfo data

    sysinfo_template$=stbl("+SYSINFO_TPL",err=*next)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=*next)
    milestone=num(stbl("+MILESTONE",err=*next),err=*next)
    firm_id$=sysinfo.firm_id$

rem --- Open/Lock Files

    if gl$<>"Y" close (printer_dev,err=*next)

rem --- Initializations

    precision i[1]
    dim a0$(20),a1$(64),a[8],b0$(23),b1$(32),b[4],c0$(23),c1$(64),c[4]
    dim d0$(23),d1$(32),d[4],ha$(23),hb$(26),hc$(26),x0$(32),x1$(4*g[4])
    dim y0$(4),y1$(32),y2$(2*g[4]),xa$(24),xb$(31),xc$(21),hd$(40)
    dim files[44],params[10],params$[10],item$[6],refs$[20],refs[20]
    item$[0]=firm_id$
    params[0]=g[0]
    params$[0]=sysinfo.system_date$
    params$[1]=sysinfo.user_id$
    params$[2]=i2$
    params$[3]=i3$
    params$[4]=i4$
 
    call pgmdir$+"ivc_itemupdt.aon::init",files[all],ivs01a$,item$[all],refs$[all],refs[all],rd_table_chans$[all],ignore_status

rem --- Get user approval to update

    msg_id$="AON_UPDT_QUERY"
    dim x$:stbl("+SYSINFO_TPL")
    dim msg_tokens$[1]
    x$=stbl("+SYSINFO")                                                            
    msg_tokens$[1]=x.task_desc$
    gosub disp_message
    if msg_opt$<>"Y" then goto std_exit_no_update

rem --- Disallow 'M'enu option in Error Routine

    exit_ctrl=1

rem --- Position file

    x=m0+11
    if aptype x=x+3
    call pgmdir$+"adc_progress.aon","N",sysinfo.task_desc$,"Purchase Order Invoice Update","Updating","",x,poe05_dev,1,0,ignore_status
    read (poe05_dev,key=firm_id$,dom=*next)

l1000: rem --- Read next header

    k$=key(poe05_dev,end=done)
    if pos(firm_id$=k$)<>1 goto done
    read record (poe05_dev) poe05a$
    x$=fnmask$(a0$(5,p[0]),m0$)+" "+a0$(11,10)
    if aptype x$=a0$(3,2)+" "+x$
    call pgmdir$+"adc_progress.aon","S","","","",x$,0,0,1,0,ignore_status

rem --- Additional reads

    dim h0$(8),h1$(30),x0$(32),x1$(4*g[4])
    x0$(1)=firm_id$+"B"+a1$(28,2)
    h0$(1)=firm_id$+a0$(5,6)
    find record (apm01_dev,key=h0$,dom=*next) apm01a$
    find record (apm10_dev,key=x0$(1,5),dom=*next) apm10b$
    apacct$=x1$(1,g[4])
    retacct$=x1$(3*g[4]+1,g[4])
    apcode$=a1$(28,2)
    gldate$=a1$(7,6)
    vendor$=h0$(3,p[0])
    name$=h1$

rem --- Create apt-01 record

    dim h0$(71),h[2]
    h0$(1)=a0$+"00"
    h0$(23,2)=a1$(28,2)
    h0$(25,2)=a1$(30,2)
    h0$(27,2)=a1$(26,2)
    h0$(29,3)=fndate$(fndate$(a1$(1,6)))
    h0$(32,3)=fndate$(fndate$(a1$(7,6)))
    h0$(35,3)=fndate$(fndate$(a1$(13,6)))
    h0$(38,3)=fndate$(fndate$(a1$(19,6)))
    h0$(41,10)=a1$(32,10)
    h0$(51,16)=a1$(42,16)
    h0$(67,1)=a1$(25,1)
    h[0]=a[0]
    h[1]=a[1]
    h[2]=a[2]
    write record (apt01_dev,key=h0$(1,22),dom=l1400) apt01a$

rem --- Generate apt-03 xrefs

    xa$(1)=firm_id$+"A"+a0$(3,8)+fndate$(fndate$(a1$(1,6)))+a0$(11)
    xb$(1)=firm_id$+"B"+a0$(3,8)+a1$(32,10)+a0$(11)
    xc$(1)=firm_id$+"C"+a0$(11,10)+a0$(3)
    write record (apt03_dev,key=xa$) apt03a$
    write record (apt03_dev,key=xb$) apt03b$
    write record (apt03_dev,key=xc$) apt03c$
    goto l1500

l1400: rem --- Adjustment to current invoice

    dim l0$(22),l1$(12),l[2]
    l0$(1)=h0$
    l1$(1,1)="A"
    l1$(2,3)=h0$(32,3)
    l1$(5,7)=h0$(41,7)
    l[all]=h[all]
    channel=apt11_dev
    x$=l0$(1,20)
    k=20
    gosub l6800
    l0$(21,2)=str(seq:"00")
    write record (apt11_dev,key=l0$) apt11a$

l1500: rem --- Update apm-02 vendor totals

    dim u0$(10),u1$(24),u2$(g[4]),u[13]
    u0$(1)=firm_id$+a0$(5,6)+a0$(3,2)
    x$=a1$(7,6)
    call pgmdir$+"adc_peryear.aon",firm_id$,sys01_dev,x$,period$,year$
    find record (apm02_dev,key=u0$,dom=*next) apm02a$
    u1$(7,3)=fndate$(fndate$(a1$(1,6)))
    u[0]=u[0]+a[0]
    u[1]=u[1]+a[2]
    if year$<=p4$(3,2) u[2]=u[2]+a[0]
    if year$>p4$(3,2) u[4]=u[4]+a[0]
    write record (apm02_dev,key=u0$) apm02a$

rem --- Generate pot-05 sequence number and position poe-15 PO Detail

    ha$(1)=a0$
    channel=pot05_dev
    x$=ha$
    k=20
    gosub l6800
    ha$(21,3)=str(seq:"000")
    read (poe15_dev,key=a0$,dom=*next)

l2000: rem --- Read next PO record

    k$=key(poe15_dev,end=l3300)
    if pos(a0$=k$)<>1 goto l3300
    read record (poe15_dev) poe15a$

rem --- Position line item file

    read (poe25_dev,key=a0$,dom=*next)

l2200: rem --- Read next line item

    k$=key(poe25_dev,end=l3200)
    if pos(a0$=k$)<>1 goto l3200
    read record (poe25_dev) poe25a$
    if c1$(1,7)<>b1$(1,7) goto l2200
    if cvs(b1$(8,7),2)<>"" if c1$(11,7)<>b1$(8,7) goto l2200

rem --- Update history detail record

    dim w0$(25),w1$(64),w2$(32),w3$(22),w4$(40),w[12]
    dim h0$(4),h1$(32),h2$(2*g[4])
    w0$(1)=firm_id$+a0$(5,6)+c1$(1,7)+c1$(11,7)+c1$(8,3)
    found=0
    find record (pot14_dev,key=w0$,dom=l2370) pot14a$
    w[8]=w[8]+c[1]
    found=1
    write record (pot14_dev,key=w0$) pot14a$
l2370:
    y0$(1)=firm_id$+c1$(18,2)
    y1$(1)=""
    y2$(1)=""
    find record (pom02_dev,key=y0$,dom=*next) pom02a$
    h0$(1)=y0$
    h1$(1)=y1$
    h2$(1)=y2$(1)

rem --- Update PO line item

    dim l0$(18),l1$(64),l2$(32),l3$(22),l4$(40),l[12]
    l0$(1)=firm_id$+a0$(5,6)+c1$(1,7)+c1$(8,3)
    find record (poe12_dev,key=l0$,dom=l2500) poe12a$
    y0$(1)=firm_id$+l1$(1,2)
    find record (pom02_dev,key=y0$,dom=*next) pom02a$
    if found if y1$(21,1)<>h1$(21,1) goto l2500
    if found if w3$<>l3$ goto l2500
    l[8]=l[8]+c[1]
    write record (poe12_dev,key=l0$) poe12a$

l2500: rem --- Calculate extension and retrieve line code

    y0$(1)=h0$
    y1$(1)=h1$
    y2$(1)=h2$
    precision 2
    extension=c[0]*c[1]
    poextension=c[2]*c[1]
    precision i[1]

rem --- Read inventory item and warehouse

    dim s0$(22),s1$(60),s2$(64),s3$(40),s4$(21),s6$(g[4]*9),s[12]
    dim u0$(24),u1$(64),u[20]
    if y1$(21,1)<>"S" goto l2700
    s0$(1)=firm_id$+w3$(3)
    u0$(1)=firm_id$+w3$
    find record (ivm01_dev,key=s0$,dom=*next) ivm01a$
    find record (ivm02_dev,key=u0$,dom=*next) ivm02a$

l2700: rem --- Generate GL Recap

    if gl$="N" goto l3100
    action$=""
    account$=""
    item$[0]=s0$(3)
    item$[1]=s1$
    item$[6]=s6$
    values[0]=extension
    values[1]=poextension
    values[2]=c[1]
    values[3]=u[0]
    arcode$=u1$(13,2)
    w$[0]=c0$
    w$[1]=c1$
    y$[0]=y0$
    y$[1]=y1$
    y$[2]=y2$
    gosub l6900

rem --- Get WIP account for Non-Stocks

    if y1$(21,1)<>"N" goto l3000
    if sf$="N" goto l3000
    if cvs(w2$(1,7),2)="" goto l3000
    dim woe01$(75),wom10$(9*g[4])
    find record (sfe01_dev,key=firm_id$+"  "+w2$(1,7),dom=l3000) sfe01a$
    find record (sfm10_dev,key=firm_id$+"A"+woe01$(12,2),dom=l3000) sfm10a$
    distaccnt$=wom10$(1,g[4]); rem "Distribution account = WIP account

l3000: rem --- Generate apt-02 records

    gosub l6000

l3100: rem --- Loop back for next line item

    hc$(1)=ha$
    hc$(24,3)=c0$(21,3)
    write record (pot25_dev,key=hc$) pot25a$
    hd$(1)=firm_id$+hc$(5,6)+c1$(1,7)+c1$(11,7)+hc$(3,2)+hc$(11,16)
    write record (pot35_dev,key=hd$) pot35a$
remove (poe25_dev,key=c0$,dom=l3190)

    goto l2200

l3200: rem --- Loop back for next PO record

    hb$(1)=ha$
    hb$(24,3)=b0$(21,3)
    write record (pot15_dev,key=hb$) pot15a$
remove (poe15_dev,key=b0$,dom=l3260)

    goto l2000

l3300: rem --- Position GL distribution file

    if gl$<>"Y" goto l3900
    dim item$[6],values[4],w$[10],y$[10]
    distribution=0
    read (poe35_dev,key=a0$,dom=*next)

l3400: rem --- Read next GL distribution record

    k$=key(poe35_dev,end=l3800)
    if pos(a0$=k$)<>1 goto l3800
    read record (poe35_dev) poe35a$

rem --- Generate GL recap postings and loop back for next record

    account$=d1$(1,g[4])
    amount=-d[0]
    values[0]=amount
    w$[0]=d0$
    w$[1]=d1$
    action$="D"
    distribution=distribution+amount
    gosub l6900

rem --- Generate apt-02 record

    gosub l6000

rem --- Loop back for next distribution record
remove (poe35_dev,key=k$,dom=l3711)

    goto l3400

l3800: rem --- Generate GL recap postings for the invoice

    if distribution=0 goto l3900
    action$="D"
    account$=apacct$
    values[0]=-distribution
    w$[0]=a0$
    if values[0] gosub l6900

l3900: rem --- Loop back for next header

    write record (pot05_dev,key=ha$) pot05a$
remove (poe05_dev,key=a0$,dom=l3930)

    goto l1000

done: rem --- Update landed cost?

    dim u0$(24),u[1],item$[3]
    if pos(r3$(55,1)="QC")=0 goto l4900
    call pgmdir$+"syc_cn.bbx","",0,7,'ce',status
    call pgmdir$+"adc_progress.aon","S","","Inventory Item Landed Costs","Updating","",3+i[0],0,1,0,ignore_status
    read (pow17_dev,key=firm_id$,dom=*next)

l4100: rem --- Read next landed cost record

    k$=key(pow17_dev,end=l4900)
    if pos(firm_id$=k$)<>1 goto l4900
    read record (pow17_dev) pow17a$
    call pgmdir$+"adc_progress.aon","S","","","",u0$(3,2)+" "+u0$(5,i[0]),0,0,1,0,ignore_status

rem --- Call standard inventory update program

    action$="PI"
    item$[0]=firm_id$
    item$[1]=u0$(3,2)
    item$[2]=u0$(5)
    refs[4]=u[0]
    call pgmdir$+"ivc_ua.bbx",action$,files[all],params[all],params$[all],item$[all],refs$[all],refs[all],status
    goto l4100

l4900: rem --- All done

    goto std_exit

l6000: rem --- Generate apt-02 record

    if cvs(distaccnt$,2)="" goto l6090
    dim t0$(34),t[1]
    t0$(1)=a0$(1,10)+"I"+a0$(11,10)+distaccnt$+fndate$(fndate$(gldate$))
    extract record (apt02_dev,key=t0$,dom=*next) apt02a$
    t[0]=t[0]+distamnt
    t[1]=t[1]+distqty
    write record (apt02_dev,key=t0$) apt02a$
l6090:
    return

l6800: rem --- Find next sequence number

    let seq=0
    read (channel,key=x$(1,k)+$ff$,dom=*next)
    let k$=keyp(channel,end=l6840)
l6840:
    if pos(x$(1,k)=k$)=1 seq=num(k$(k+1))+1
    return

l6900: rem --- Call GL Posting Routine

    let glfiles[1]=glm01_dev,glfiles[2]=glt04_dev,glfiles[3]=glt14_dev
    let glfiles[4]=apm10_dev,glfiles[5]=arm10_dev,glparams$[0]=firm_id$
    let glparams$[1]=apcode$,glparams$[2]=arcode$,glparams$[3]=distcode$
    let glparams$[4]=gldate$,glparams$[5]=vendor$,glparams$[6]=name$
    let glparams$[7]=m0$,glparams$[8]=g4$,glparams$[9]=i3$(8,1)
    let glparams$[10]=account$,glparams[0]=i[0],glparams[1]=i[1]
    let glparams[2]=g[4],glparams[3]=i[3],glparams[4]=i[4],glparams[5]=i[5]
    dim glaccounts$[5],glamounts[5],glqtys[5]
    call pgmdir$+"poc_gb.bbx",action$,glfiles[all],glparams$[all],glparams[all],item$[all],w$[all],y$[all],values[all],glaccounts$[all],glamounts[all],glqtys[all],status
    let distaccnt$=glaccounts$[1],distamnt=-glamounts[0],distqty=-glqtys[0]; rem "Distribution account = PO account, Distribution amount and quantity = -(AP amount and quantity)
    if y1$(21,1)="S" distaccnt$=glaccounts$[4]; rem "For S-line types, Distribution account = IV account, Distribution amount and quantity = -(AP amount and quantity)
    if action$="D" distaccnt$=glaccounts$[0],distamnt=-distamnt,distqty=-distqty; rem "For GL distribution, Distribution account = AP account, Distribution amount and quantity = AP amount and quantity
    return

rem #include std_functions.src
rem --- Standard AddonSoftware functions (01Mar2006)
rem --- Functions used to retrieve form values

    def fnstr_pos(q0$,q1$,q1)=int((pos(q0$=q1$,q1)+q1-1)/q1)
    def fnget_rec_date$(q0$)=rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                            cvs(q0$,1+2+4),rd_rec_data$[0,0],40),0]
    def fnget_fld_data$(q0$,q1$)=cvs(rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                                cvs(q1$,1+2+4),rd_rec_data$[0,0],40),0],2)
    def fnget_table$(q0$)=rd_alias_id$

rem --- Miscellaneous functions

    def fncenter(q$,q)=int((q-len(q$))/2)

rem --- Format inventory item description

    def fnitem$(q$,q1,q2,q3)=cvs(q$(1,q1)+" "+q$(q1+1,q2)+" "+q$(q1+q2+1,q3),32)

rem --- Format zip/postal code

    def fnzipcode$(q$)
        q$=cvs(q$,4)
        if len(cvs(q$,2))<>9 and len(cvs(q$,2))<>6 return q$
        if len(cvs(q$,2))=9
            q1$="[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]"
            q1=mask(cvs(q$,2),q1$)
            if q1=0 return q$
            if q1<>0
                if q$(6,4)="0000" return q$(1,5)
            return q$(1,5)+"-"+q$(6,4)
            endif
        endif
        if len(cvs(q$,2))=6
            q1$="[a-zA-Z][0-9][a-zA-Z][0-9][a-zA-Z][0-9]"
            q1=mask(cvs(q$,2),q1$)
            if q1=0 return q$ else return q$(1,3)+" "+q$(4,3)
        endif
    fnend

rem --- Date/time handling functions

    def fndate$(q$)
        q1$=""
        q1$=date(jul(num(q$(1,4)),num(q$(5,2)),num(q$(7,2)),err=*next),err=*next)
        if q1$="" q1$=q$
        return q1$
    fnend
    def fnyy$(q$)=q$(3,2)
    def fnclock$(q$)=date(0:"%hz:%mz %p")
    def fntime$(q$)=date(0:"%Hz%mz")

rem --- fnmask$: Alphanumeric Masking Function (formerly fnf$)

    def fnmask$(q1$,q2$)
        if q2$="" q2$=fill(len(q1$),"0")
        return str(-num(q1$,err=*next):q2$,err=*next)
        q=1
        q0=0
        while len(q2$(q))
              if pos(q2$(q,1)="-()") q0=q0+1 else q2$(q,1)="X"
              q=q+1
        wend
        if len(q1$)>len(q2$)-q0 q1$=q1$(1,len(q2$)-q0)
        return str(q1$:q2$)
    fnend

rem --- fnbasename$: Strip path and optionally the suffix from a file name

    def fnbasename$(q$,q0$)
        q=max(pos("/"=q$,-1),pos(":"=q$,-1),pos(">"=q$,-1),pos("\"=q$,-1))
        if q then q$=q$(q+1)
        if q0$<>"" then q=mask(q$,q0$); if q q$=q$(1,q-1)
    return q$

rem --- fnglobal: Return numeric value of passed stbl variable

    def fnglobal(q$,q1)
        q1$=stbl(q$,err=*next),q1=num(q1$,err=*next)
        return q1
    fnend

rem --- fnglobal$: Return string value of passed STBL variable

    def fnglobal$(q$,q1$)
        q1$=stbl(q$,err=*next)
        return q1$
    fnend

rem #endinclude std_functions.src

rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    call stbl("+DIR_SYP")+"bac_error.bbj",err=std_error_exit,pgm(-2),str(tcb(5)),
:                                str(err),rd_err_text$,rd_err_act$
    if pos("EXIT"=rd_err_act$) goto std_error_exit
    if pos("ESCAPE"=rd_err_act$) seterr 0;setesc 0
    if pos("RETRY"=rd_err_act$) retry
std_error_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_error_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_error_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_error.src

rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5)),
:                                   str(err),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_end.src

std_exit: rem --- Standard program end (01Mar2006)

    msg_id$="UPDATE_COMPLETE"
    dim msg_tokens$[1]
    msg_opt$=""
    gosub disp_message

std_exit_no_update:

    call pgmdir$+"adc_progress.aon","D","","","","",0,0,0,meter_num,status
    run stbl("+DIR_SYP")+"bas_process_end.bbj",err=*next
    release
rem #endinclude std_end.src

    end