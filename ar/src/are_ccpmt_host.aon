rem --- are_creditpmt.aon - process credit card payment using J2Pay library or hosted page (PayPal or Authorize.net)
rem --- Copyright BASIS International Ltd.  All Rights Reserved.

    use org.json.JSONObject

	use java.math.BigDecimal
	use java.math.RoundingMode
    use java.util.UUID
    use java.util.Iterator

	use ::REST/BBWebClient.bbj::BBWebClient
	use ::REST/BBWebClient.bbj::BBWebRequest
	use ::REST/BBWebClient.bbj::BBWebResponse

	use net.authorize.Environment
	use net.authorize.api.contract.v1.MerchantAuthenticationType
	use net.authorize.api.contract.v1.TransactionRequestType
	use net.authorize.api.contract.v1.SettingType
	use net.authorize.api.contract.v1.ArrayOfSetting
	use net.authorize.api.contract.v1.MessageTypeEnum
	use net.authorize.api.contract.v1.TransactionTypeEnum
	use net.authorize.api.contract.v1.GetHostedPaymentPageRequest
	use net.authorize.api.contract.v1.GetHostedPaymentPageResponse
	use net.authorize.api.contract.v1.GetTransactionDetailsRequest
	use net.authorize.api.contract.v1.OrderType
	use net.authorize.api.controller.base.ApiOperationBase
	use net.authorize.api.controller.GetHostedPaymentPageController
	use net.authorize.api.controller.GetTransactionDetailsController

    use com.tranxactive.j2pay.gateways.parameters.Customer
    use com.tranxactive.j2pay.gateways.parameters.CustomerCard
    use com.tranxactive.j2pay.gateways.parameters.Currency
    use com.tranxactive.j2pay.gateways.parameters.Country

    use com.tranxactive.j2pay.gateways.core.Gateway
    use com.tranxactive.j2pay.gateways.core.GatewayFactory
    use com.tranxactive.j2pay.gateways.core.AvailableGateways
    use com.tranxactive.j2pay.gateways.core.GatewaySampleParameters

    use com.tranxactive.j2pay.net.HTTPResponse
    use com.tranxactive.j2pay.net.JSONHelper

    setesc std_error
    seterr std_error

rem --- Retrieve sysinfo data

    sysinfo_template$=stbl("+SYSINFO_TPL",err=*next)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=*next)
    firm_id$=sysinfo.firm_id$

rem --- Open/Lock files

    num_files=5
    dim open_tables$[1:num_files],open_opts$[1:num_files],open_chans$[1:num_files],open_tpls$[1:num_files]
    open_tables$[1]="ART_RESPONSE",open_opts$[1]="OTA"
    open_tables$[2]="ARE_CASHHDR",open_opts$[2]="OTA"
    open_tables$[3]="ARE_CASHDET",open_opts$[3]="OTA"
    open_tables$[4]="ARE_CASHBAL",open_opts$[4]="OTA"
    open_tables$[5]="ARS_CC_CUSTSVC",open_opts$[5]="OTA"

    gosub open_tables

    art_response=num(open_chans$[1])
    are_cashhdr=num(open_chans$[2])
    are_cashdet=num(open_chans$[3])
    are_cashbal=num(open_chans$[4])
    ars_cc_custsvc=num(open_chans$[5])

    dim art_response$:open_tpls$[1]
    dim are_cashhdr$:open_tpls$[2]
    dim are_cashdet$:open_tpls$[3]
    dim are_cashbal$:open_tpls$[4]
    dim ars_cc_custsvc$:open_tpls$[5]

rem --- read params to get interface type (internal API via J2Pay, or hosted page), which gateway, and list of invoices/payment amount specified to pay
    readrecord(ars_cc_custsvc,key=firm_id$+"AR00",dom=*next)ars_cc_custsvc$
    interface_tp$=ars_cc_custsvc.interface_tp$
    gateway$=cvs(ars_cc_custsvc.gateway$,7)

    vectInvoices!=callpoint!.getDevObject("vectInvoices")
    apply_amt!=cast(BBjNumber, num(option!.getOptionData("<<DISPLAY>>.APPLY_AMT")))
    cust_id$=option!.getOptionData("CUSTOMER_ID")

rem --- Assign form input values to local variables
    if interface_tp$="A"
        name_first$=option!.getOptionData("NAME_FIRST")
        name_last$=option!.getOptionData("NAME_LAST")
        address_line_1$=option!.getOptionData("ADDRESS_LINE_1")
        address_line_2$=option!.getOptionData("ADDRESS_LINE_2")
        city$=option!.getOptionData("CITY")
        state_code$=option!.getOptionData("STATE_CODE")
        zip_code$=option!.getOptionData("ZIP_CODE")
        cntry_id$=option!.getOptionData("CNTRY_ID")
        phone_no$=option!.getOptionData("PHONE_NO")
        email_addr$=option!.getOptionData("EMAIL_ADDR")

        card_no$=callpoint!.getDevObject("card_no")
        security_cd$=callpoint!.getDevObject("security_cd")
        month$=callpoint!.getDevObject("month")
        year$=callpoint!.getDevObject("year")

        callpoint!.setDevObject("card_no","")
        callpoint!.setDevObject("security_cd","")
        callpoint!.setDevObject("month","")
        callpoint!.setDevObject("year","")

        ip$="127.0.0.1"

        rem --- Use J2Pay library
        gw! = new GatewayFactory()
        apiSampleParameters! = new JSONObject()
        
        switch gateway$
            case "AUTHORIZE"
                gateway!=gw!.getGateway(AvailableGateways.AUTHORIZE)
                apiSampleParameters! = gateway!.getApiSampleParameters()
                apiSampleParameters!.put("name", "58rvyVe2Ns")
                apiSampleParameters!.put("transactionKey", "23bm952fK8UR74FM")
            break
            case "PAYFLOWPRO"
                gateway!=gw!.getGateway(AvailableGateways.PAYFLOWPRO)
                apiSampleParameters! = gateway!.getApiSampleParameters()
                apiSampleParameters!.put("PARTNER", "PayPal")
                apiSampleParameters!.put("VENDOR", "AONtesting")
                apiSampleParameters!.put("USER", "CHawkins")
                apiSampleParameters!.put("PWD", "Titp4CH")
            break
            case default
                rem other J2Pay gateways: PAYEEZY, EASYPAY, BILLPRO, NMI
            break
        swend

        gateway!.setTestMode(BBjAPI.TRUE)

        customer! = new Customer()
        customer!.setFirstName(name_first$)
        customer!.setLastName(name_last$)
        customer!.setCountry(Country.valueOf(cntry_id$))
        customer!.setState(state_code$)
        customer!.setCity(city$)
        customer!.setAddress(address_line_1$+" "+address_line_2$)
        customer!.setZip(zip_code$)
        customer!.setPhoneNumber(phone_no$)
        customer!.setEmail(email_addr$)
        customer!.setIp("127.0.0.1");rem only required by BillPro AFAIK

        customerCard! = new CustomerCard()
        customerCard!.setName(name_first$+" "+name_last$)
        customerCard!.setNumber(card_no$);rem note - only certain credit card numbers allowed for testing
        customerCard!.setCvv(security_cd$)
        customerCard!.setExpiryMonth(month$)
        customerCard!.setExpiryYear(year$)
     
        response! = new HTTPResponse()
        response! = gateway!.purchase(apiSampleParameters!, customer!, customerCard!, Currency.USD, apply_amt!.floatValue())
     
        rem --- write response to history file
        trans_id$=""
        full_response!=response!.getJSONResponse()
        trans_id$=full_response!.get("lr").get("transactionId",err=*next)
        trans_msg$=full_response!.get("lr").get("message")

        rem --- write response text to art_response
        if trans_id$<>""
            response_text$=full_response!.toString()
            gosub write_to_response_log
        endif

        rem --- if transaction was approved, create cash receipt
        if response!.isSuccessful()
            gosub create_cash_receipt
        else
            cash_msg$=""
        endif

		dim msg_tokens$[1]
		msg_tokens$[0]=trans_msg$+$0A$+cash_msg$
		msg_id$="GENERIC_OK"
		gosub disp_message

		goto std_exit

    else

        rem --- using Authorize.net or PayPal hosted page (interface_tp$="H")
        switch gateway$
            case "PAYFLOWPRO"
                rem --- get random number to send when requesting secure token
                rem --- set namespace variable using that number
                rem --- PayPal returns that number in the response, so can match number in response to number we're sending to be sure we're processing our payment and not someone else's (multi-user)
                sid!=UUID.randomUUID()
                sid$=sid!.toString()
                callpoint!.setDevObject("sid",sid$)
                ns!=BBjAPI().getNamespace("aon","credit_receipt_paypal",1)
                ns!.setValue(sid$,"init")
                ns!.setCallbackForVariableChange(sid$,"paypal_response")
           
                rem --- use BBj's REST API to send sid$ and receive back secure token
                rem --- TODO CAH the setURI(), setContent(), and browse() methods need to get info from ars_payflowpro
                client!=new BBWebClient()
                request!=new BBWebRequest()
                request!.setURI("https://pilot-payflowpro.paypal.com")
                request!.setMethod("POST") 
                request!.setContent("PARTNER=PayPal&VENDOR=AONtesting&USER=CHawkins&PWD=Titp4CH&TRXTYPE=S&AMT="+str(apply_amt!:"###,###.00")+"&CREATESECURETOKEN=Y&SECURETOKENID="+sid!.toString())
                response! = client!.sendRequest(request!) 
                content!=response!.getBody()
                response!.close()

                tokenID!=content!.substring(content!.indexOf("SECURETOKEN=")+11)
                tokenID!=tokenID!.substring(1,tokenID!.indexOf("&"))

                rem --- if successful in getting secure token, launch hosted page
                rem --- PayPal Silent Post configuration will contain return URL that runs a BBJSP servlet once payment is completed (or declined)
                rem --- servlet updates namespace variable sid$ with response text
                rem --- registered callback for variable change will cause paypal_response routine to get executed
                rem --- paypal_response will record response in art_response and post cash receipt, if applicable
                if content!.contains("RESULT=0")
                    BBjAPI().getThinClient().browse("https://pilot-payflowlink.paypal.com?SECURETOKENID="+sid!.toString()+"&SECURETOKEN="+tokenID!)
                else
                    trans_msg$="Unable to acquire secure token from PayPal."
                endif
            break
            case "AUTHORIZE"
                ns!=BBjAPI().getNamespace("aon","credit_receipt_authorize",1)
                ns!.setCallbackForNamespace("authorize_response")

                rem --- Create the order object to add to transaction request
                rem --- Currently filling with unique ID so we can link this auth-capture to returned response
                rem --- Authorize.net next API version should allow refID to be passed that will be returned in Webhook, obviating need for unique ID in order
                rem --- TODO CAH will need to change Environment.SANDBOX to LIVE --- when? After VAR tests? 
                rem --- TODO CAH get Name and TransactionKey from ars_authorize, along with URLs for our 'starter' payment page and confirmation pages

                sid!=UUID.randomUUID()
                sid$=sid!.toString()
                callpoint!.setDevObject("sid",sid$)
                order! = new OrderType()
                order!.setInvoiceNumber(cust_id$)
                order!.setDescription(sid$)

                ApiOperationBase.setEnvironment(Environment.SANDBOX)

                merchantAuthenticationType!  = new MerchantAuthenticationType() 
                merchantAuthenticationType!.setName("58rvyVe2Ns")
                merchantAuthenticationType!.setTransactionKey("23bm952fK8UR74FM")
                ApiOperationBase.setMerchantAuthentication(merchantAuthenticationType!)

                rem Create the payment transaction request
                txnRequest! = new TransactionRequestType()
                txnRequest!.setTransactionType(TransactionTypeEnum.AUTH_CAPTURE_TRANSACTION.value())
                txnRequest!.setAmount(new BigDecimal(apply_amt!).setScale(2, RoundingMode.CEILING))
                txnRequest!.setOrder(order!)

                setting1! = new SettingType()
                setting1!.setSettingName("hostedPaymentButtonOptions")
                setting1!.setSettingValue("{"+$22$+"text"+$22$+": "+$22$+"Pay"+$22$+"}")
                        
                setting2! = new SettingType()
                setting2!.setSettingName("hostedPaymentOrderOptions")
                setting2!.setSettingValue("{"+$22$+"show"+$22$+": false}")

                setting3! = new SettingType()
                setting3!.setSettingName("hostedPaymentReturnOptions")
                setting3!.setSettingValue("{"+$22$+"showReceipt"+$22$+": true, "+$22$+"url"+$22$+": "+$22$+"https://test.basis.com:443/bbjsp/authnetconf"+$22$+", "+$22$+"urlText"+$22$+": "+$22$+"Continue"+$22$+"}")

                alist! = new ArrayOfSetting()
                alist!.getSetting().add(setting1!)
                alist!.getSetting().add(setting2!)
                alist!.getSetting().add(setting3!)

                apiRequest! = new GetHostedPaymentPageRequest()
                apiRequest!.setTransactionRequest(txnRequest!)
                apiRequest!.setHostedPaymentSettings(alist!)

                controller! = new GetHostedPaymentPageController(apiRequest!)
                controller!.execute()
                       
                authResponse! = new GetHostedPaymentPageResponse()
                authResponse! = controller!.getApiResponse()

                rem --- if GetHostedPaymentPageResponse() indicates success, launch our 'starter' page.
                rem --- 'starter' page gets passed the token, and has a 'proceed to checkout' button, which does a POST to https://test.authorize.net/payment/payment, passing along the token.
                rem --- Authorize.net is configured with Webhook for the auth-capture transaction. Webhook contains URL that runs our BBJSP servlet.
                rem --- Servlet updates namespace variable 'authresp' with response text
                rem --- registered callback for variable change will cause authorize_response routine to get executed
                rem --- authorize_response will parse trans_id from the webhook, then send a getTransactionDetailsRequest
                rem --- returned getTransactionDetailsResponse should contain order with our sid$ in the order description
                rem --- if sid$ matches saved_sid$, then this is our response (and not someone else's who might also be processing payments)
                rem --- assuming this is our response, record the Webhook response in art_response and create cash receipt, if applicable
                if authResponse!.getMessages().getResultCode()=MessageTypeEnum.OK
                    BBjAPI().getThinClient().browse("https://test.basis.com:443/AuthorizeHostedPayment.htm?authtoken="+authResponse!.getToken())
                else
                    trans_msg$="Unable to acquire secure token. Response: "+$0a$+authResponse!.getMessages().getMessage().get(0).getCode()+$0a$+authResponse!.getMessages().getMessage().get(0).getText();rem --- TODO CAH needs localization
                endif
            break
            case default
                escape;rem shouldn't get here
            break
        swend
    
    endif
	
	process_events,err=*same
    
    goto std_exit

write_to_response_log:rem --- write to art_response
rem --- in: firm_id$, cust_id$, trans_id$, response_text$, vectInvoices!
    for inv_row=0 to vectInvoices!.size()-1 step 7
        pay_flag$=vectInvoices!.get(inv_row)
        if pay_flag$="Y"
            ar_inv_no$=vectInvoices!.get(inv_row+1)
            redim art_response$
            art_response.firm_id$=firm_id$
            art_response.customer_id$=cust_id$
            art_response.ar_inv_no$=ar_inv_no$
            art_response.transaction_id$=trans_id$
            art_response.response_text$=response_text$
            art_response.created_user$=sysinfo.user_id$
            art_response.created_date$=date(0:"%Yd%Mz%Dz")
            art_response.created_time$=date(0:"%Hz%mz")
            art_response$=field(art_response$)
            writerecord(art_response)art_response$
        endif
    next inv_row

    return

create_cash_receipt:
rem --- in: firm_id$, cust_id$, apply_amt!, trans_id$, vectInvoices!

    rem --- write are_cashhdr
    rem --- TODO CAH need to read/update, not just create, as >1 payment could have been made so header already exists
    rem --- TODO CAH same for are_cashbal/are_cashdet, don't just create them
    rem --- TODO CAH also need to add logic to use deposit_ID and batch_no, and update ars_cc_custsvc with same
    rem --- TODO CAH if there is already an are_cashdet for this invoice with balance < pay amount, apply on account

    are_cashhdr$.firm_id$=firm_id$
    are_cashhdr.receipt_date$=stbl("+SYSTEM_DATE")
    are_cashhdr.customer_id$=cust_id$
    are_cashhdr.cash_rec_cd$="C"
    are_cashhdr.payment_amt=apply_amt!
    are_cashhdr.batch_no$="0000000"
    are_cashhdr.memo_1024$=$01$
    are_cashhdr$=field(are_cashhdr$)
    writerecord(are_cashhdr)are_cashhdr$

    rem --- now write are_cashdet and are_cashbal recs for each invoice in vectInvoices!
    for inv_row=0 to vectInvoices!.size()-1 step 7
        pay_flag$=vectInvoices!.get(inv_row)
        if pay_flag$="Y"
            ar_inv_no$=vectInvoices!.get(inv_row+1)
            invoice_bal$=vectInvoices!.get(inv_row+5)
            invoice_pay$=vectInvoices!.get(inv_row+6)
            
            redim are_cashdet$
            redim are_cashbal$

            are_cashdet.firm_id$=firm_id$
            are_cashdet.receipt_date$=are_cashhdr.receipt_date$
            are_cashdet.customer_id$=are_cashhdr.customer_id$
            are_cashdet.cash_rec_cd$=are_cashhdr.cash_rec_cd$
            are_cashdet.ar_inv_no$=ar_inv_no$
            are_cashdet.apply_amt$=invoice_pay$
            are_cashdet.batch_no$=are_cashhdr.batch_no$
            are_cashdet.transaction_id$=trans_id$
            are_cashdet.memo_1024$=$01$
            are_cashdet.firm_id$=field(are_cashdet$)
            writerecord(are_cashdet)are_cashdet$

            are_cashbal.firm_id$=firm_id$
            are_cashbal.customer_id$=are_cashhdr.customer_id$
            are_cashbal.ar_inv_no$=ar_inv_no$
            are_cashbal.apply_amt$=invoice_pay$
            are_cashbal$=field(are_cashbal$)
            writerecord(are_cashbal)are_cashbal$

        endif
    next inv_row
    cash_msg$="Cash Receipt has been entered.";rem --- TODO CAH needs localization
    
    return

paypal_response:rem --- process silent post response from PayPal
	ev!=BBjAPI().getLastEvent()
	old_value$=ev!.getOldValue()
    if old_value$="init"
        new_value$=ev!.getNewValue()
        trans_id$=fnparse$(new_value$,"PNREF=","&")
        payment_amt$=str(num(fnparse$(new_value$,"AMT=","&")))
        trans_msg$=fnparse$(new_value$,"RESPMSG","&")
        if cvs(trans_id$,3)<>""
            response_text$=new_value$
            gosub write_to_response_log
        endif
        if fnparse$(new_value$,"RESULT=","&")="0"
            gosub create_cash_receipt
        else
            cash_msg$=""
        endif
    endif

	exitto std_exit

    return

authorize_response:rem --- process webhook response from Authorize.net
	ev!=BBjAPI().getLastEvent()
	newValue! = new JSONObject(ev!.getNewValue())
	trans_id$=newValue!.get("payload").get("id")

	ApiOperationBase.setEnvironment(Environment.SANDBOX)

	merchantAuthenticationType!  = new MerchantAuthenticationType() 
	merchantAuthenticationType!.setName("58rvyVe2Ns");rem TODO CAH get from ars_authorize
	merchantAuthenticationType!.setTransactionKey("23bm952fK8UR74FM")
	ApiOperationBase.setMerchantAuthentication(merchantAuthenticationType!)
	
	getRequest! = new GetTransactionDetailsRequest()
	getRequest!.setMerchantAuthentication(merchantAuthenticationType!)
	getRequest!.setTransId(trans_id$)

	controller! = new GetTransactionDetailsController(getRequest!)
	controller!.execute()
	authResponse! = controller!.getApiResponse()
	if authResponse!.getMessages().getResultCode()=MessageTypeEnum.OK
		resp_cust$=authResponse!.getTransaction().getOrder().getInvoiceNumber()
		resp_sid$=authResponse!.getTransaction().getOrder().getDescription()
		resp_code=authResponse!.getTransaction().getResponseCode()
		payment_amt$=str(authResponse!.getTransaction().getAuthAmount())

		rem if sid_in$ matches callpoint!.getDevObject("sid") then this is a response to OUR payment
		rem this is a workaround until Authorize.net returns our assigned refID in the webhook response
		rem until then, don't know if this event got triggered by us, or someone else processing a credit card payment
		rem so we have to put the sid$ in something that gets returned in the full response, and get that full response
		rem instead of just using the returned webhook
		rem may want to always get full response to record in art_response, since webhook payload is abridged
escape;rem sid$? resp_sid$? resp_code? resp_cust$? CAH        
		if resp_sid$=sid$
			response_text$=newValue!.toString()
			gosub write_to_response_log
		endif
		if resp_code
			gosub create_cash_receipt
		else
			cash_msg$=""
		endif
    else
        rem --- TODO CAH should put something in a message here about not being successful at getting the message response
   endif
	
	exitto std_exit

    return

open_tables:rem --- Open Tables

	call stbl("+DIR_SYP")+"bac_open_tables.bbj",
:		open_beg,
:		open_end,
:		open_tables$[all],
:		open_opts$[all],
:		open_chans$[all],
:		open_tpls$[all],
:		rd_table_chans$[all],
:		open_batch,
:		open_status$

	if open_status$<>""
		msg_id$="ENTRY_OPEN_ERROR"
		dim msg_tokens$[1]
			msg_tokens$[1]=open_status$
		gosub disp_message
		goto std_exit
	endif

	return

disp_message:rem --- Display Message Dialog

	call stbl("+DIR_SYP")+"bac_message.bbj",
:		msg_id$,
:		msg_tokens$[all],
:		msg_opt$,
:		rd_table_chans$[all]

	return

rem #include std_error.src

std_error: rem --- Standard error handler (11Oct2017)

    if tcb(19)>0
        rem --- Escape handler
        if and(chr(tcb(19)),$08$)=$08$
            release
        else
            setesc std_error
            return
        endif
    endif

    if err=0   
        rem --- Get tcb(12) and tcb(10) to send into bac_error
        lock_byte=tcb(10)
        lock_chan=tcb(12)  
    endif

    rd_err_text$="",err_num=err
    if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
    if err_num=252 then
        E!=BBjAPI().getLastBBjException()
        rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
        if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
    endif
    call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$,lock_byte,lock_chan
    if pos("ESCAPE"=rd_err_act$) seterr 0; setesc 0
    if pos("RETRY"=rd_err_act$) retry
    if pgm(-1)<>pgm(-2) status=999; exit 
    release

rem #endinclude std_error.src

std_exit: rem --- Standard program end (01Mar2006)



    run stbl("+DIR_SYP",err=*next)+"bas_process_end.bbj",err=*next
    release
