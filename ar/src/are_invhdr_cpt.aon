rem Callpoint program for ARE_INVHDR
rem Program are_invhdr_cpt.aon v8.0.0 25Apr2006

rem AddonSoftware Version 8.0.0 - 01Oct2006
rem Copyright (c) 1981-2006 AddonSoftware
rem All Rights Reserved

	seterr std_error
	setesc std_error

	enter callpoint$,
:		aon_tpl$,
:		AONObj!,
:		user_tpl$,
:		rdUserObj!,
:		gui_dev,
:		rdSysGUI!,
:		rdForm!,
:		attr_tbl$[all],
:		attr_col$[all],
:		attr_def_tbl$[all],
:		attr_def_col$[all],
:		rec_data$,
:		rec_data$[all],
:		table_chans$[all],
:		dtlg_param$[all],
:		rdGridVect!,
:       hrec_data$[all],
:       hattr_col$[all],
:		err=*next

rem --- Initializations

	dim cp_data$:fattr(callpoint$)
	cp_data$=callpoint$

	callpoint_alias$=cp_data.callpoint_alias$
	callpoint_type$=cp_data.callpoint_type$
	callpoint_id$=cp_data.callpoint_id$(1,4)
	callpoint_ctl$=cp_data.callpoint_ctl$
	callpoint_var$=cp_data.callpoint_dvar$
	callpoint_data$=cp_data.callpoint_data$
	callpoint_key$=cp_data.callpoint_key$
	callpoint_pfx$=cp_data.callpoint_pfx$

rem --- Local variables


rem --- Retrieve the program path

    pgmdir$=stbl("+DIR_PGM",err=*next)

rem --- Retrieve sysinfo data

    sysinfo_template$=stbl("+SYSINFO_TPL",err=*next)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=*next)
    firm_id$=sysinfo.firm_id$

rem --- Callpoints and tables handled by this program

	callpoint_id_str$=
:		"ACAL;ADEL;ADEQ;ADIS;AENA;AGCL;AGDS;AGRD;AKEY;AOPT;AOVE;APRA;APRT;ARAR;ARCO;AREA;AREC;AREM;ASHO;ASIZ;AWRI;"+
:		"BDEL;BDEQ;BENA;BEND;BGRD;BNEK;BNEX;BOVE;BPRI;BPRK;BRCO;BREA;BREC;BREM;BSAV;BSHO;BWAR;BWRI;"+
:		"AINP;AINQ;AVAL;AVEC;BINP;BINQ;"

	callpoint_var_str$=
:		pad("ARE_INVHDR.AR_INV_NO",40)+
:		pad("ARE_INVHDR.CUSTOMER_ID",40)+
:		pad("ARE_INVHDR.AR_DIST_CODE",40)+
:		pad("ARE_INVHDR.FIRM_ID",40)+
:		pad("ARE_INVHDR.INV_DATE",40)+
:		pad("ARE_INVHDR.RESERVED_STR",40)+
:		pad("ARE_INVHDR.RESERVED_STR",40)+
:		pad("ARE_INVHDR.SEQUENCE_000",40)+
:		pad("ARE_INVHDR.SIM_INV_TYPE",40)+
:		pad("ARE_INVHDR.AR_TERMS_CODE",40)+
:		pad("ARE_INVDET.GL_ACCOUNT",40)+
:		pad("ARE_INVDET.DESCRIPTION",40)+
:		pad("ARE_INVDET.TRNS_DATE",40)+
:		pad("ARE_INVDET.UNITS",40)+
:		pad("ARE_INVDET.UNIT_PRICE",40)+
:		pad("ARE_INVDET.EXT_PRICE",40)

    callpoint_opt_str$="TOTS;OPT2;OPT3;";rem ---  option string for AOPT callpoints

rem --- Route table callpoint to correct subroutine (Table callpoint if callpoint_var$=null)

	if cvs(callpoint_var$,2)=""
		switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
			case fnstr_pos("ACAL",callpoint_id_str$,5);rem After Form Callbacks
			break
			case fnstr_pos("ADEL",callpoint_id_str$,5);rem After Record Delete

                rem --- hdr/dtl have been deleted; now write back header w/ "V" flag
                tablepos=pos("ARE_INVHDR"=table_chans$[0,0],20)
                are_invhdr_dev=num(table_chans$[0,0](tablepos+17,3))
                rec_data.sim_inv_type$="V"
                rec_data$=field(rec_data$); write record(are_invhdr_dev,key=rec_data.firm_id$+rec_data.ar_inv_no$)rec_data$

			break
			case fnstr_pos("ADEQ",callpoint_id_str$,5);rem After Delete Query
			break
			case fnstr_pos("ADIS",callpoint_id_str$,5);rem After Record Display

                cust_key$=fnget_rec$("ARE_INVHDR.FIRM_ID")+fnget_rec$("ARE_INVHDR.CUSTOMER_ID")
                gosub disp_cust_addr
                callpoint.callpoint_stat$="REFRESH"

                if fnget_rec$("ARE_INVHDR.SIM_INV_TYPE")="V"
                    gosub check_outstanding_inv
                    if os_inv$="N"
                        rd_msg_id$="AR_VOID_INV"
                        dim rd_msg_tokens$[1]
                        rd_msg_opt$=""
                        gosub disp_message
                        if rd_msg_opt$="Y"
                            rec_data$[fnstr_pos("ARE_INVHDR.SIM_INV_TYPE",rec_data$[0,0],40),0]="I"
                            rec_data$[fnstr_pos("ARE_INVHDR.SIM_INV_TYPE",rec_data$[0,0],40),1]="I"
                            callpoint.callpoint_stat$="MODIFIED-REFRESH"
                        else
                            callpoint.callpoint_stat$="ABORT"
                        endif
                    else
                        rd_msg_id$="AR_INV_ADJ"
                        dim rd_msg_tokens$[1]
                        rd_msg_opt$=""
                        gosub disp_message
                        if rd_msg_opt$="Y"
                            rec_data$[fnstr_pos("ARE_INVHDR.SIM_INV_TYPE",rec_data$[0,0],40),0]="A"
                            rec_data$[fnstr_pos("ARE_INVHDR.SIM_INV_TYPE",rec_data$[0,0],40),1]="A"
                            callpoint.callpoint_stat$="MODIFIED-REFRESH"
                        else
                            callpoint.callpoint_stat$="ABORT"
                        endif
                    endif
                endif


			break
			case fnstr_pos("AENA",callpoint_id_str$,5);rem After Enable Map
			break
			case fnstr_pos("AGCL",callpoint_id_str$,5);rem After Grid Clear
			break
			case fnstr_pos("AGDS",callpoint_id_str$,5);rem After Grid Display

                gosub calc_grid_tots

                hrec_data$[fnstr_pos("<<DISPLAY>>.TOT_QTY",hrec_data$[0,0],40),0]=str(tqty)
                hrec_data$[fnstr_pos("<<DISPLAY>>.TOT_AMT",hrec_data$[0,0],40),0]=str(tamt)

			break
			case fnstr_pos("AGRD",callpoint_id_str$,5);rem After Grid Exit
			break
			case fnstr_pos("AKEY",callpoint_id_str$,5);rem After Key Build
			break
			case fnstr_pos("AOPT",callpoint_id_str$,5);rem After Option Select
				switch fnstr_pos(cp_data.callpoint_id$(6),callpoint_opt_str$,5)
rem					case fnstr_pos("OPT1",callpoint_opt_str$,5);rem Option 1 Select Sample                        
rem					break
rem					case fnstr_pos("OPT2",callpoint_opt_str$,5);rem Option 2 Select Sample
rem					break
rem					case fnstr_pos("OPT3",callpoint_opt_str$,5);rem Option 3 Select Sample
rem					break
				swend
			break
			case fnstr_pos("AOVE",callpoint_id_str$,5);rem After Table Overview
			break
			case fnstr_pos("APRA",callpoint_id_str$,5);rem After Print All Select
			break
			case fnstr_pos("APRT",callpoint_id_str$,5);rem After Print Rec Select
			break
			case fnstr_pos("ARAR",callpoint_id_str$,5);rem After Array Transfer
			break
			case fnstr_pos("ARCO",callpoint_id_str$,5);rem After Record Copy
			break
			case fnstr_pos("AREA",callpoint_id_str$,5);rem After Record Read
			break
			case fnstr_pos("AREC",callpoint_id_str$,5);rem After New Record
			break
			case fnstr_pos("AREM",callpoint_id_str$,5);rem After Record Removal
			break
			case fnstr_pos("ASHO",callpoint_id_str$,5);rem After Window Show
			break
			case fnstr_pos("ASIZ",callpoint_id_str$,5);rem After Window Resize
			break
			case fnstr_pos("AWRI",callpoint_id_str$,5);rem After Record Write
			break
			case fnstr_pos("BDEL",callpoint_id_str$,5);rem Before Record Delete
			break
			case fnstr_pos("BDEQ",callpoint_id_str$,5);rem Before Delete Query
			break
			case fnstr_pos("BENA",callpoint_id_str$,5);rem Before Enable Map
			break
			case fnstr_pos("BEND",callpoint_id_str$,5);rem Before Table Exit
			break
			case fnstr_pos("BGRD",callpoint_id_str$,5);rem Before Grid Entry
			break
			case fnstr_pos("BNEK",callpoint_id_str$,5);rem Before Next Record Key
			break
			case fnstr_pos("BNEX",callpoint_id_str$,5);rem Before Next Record
			break
			case fnstr_pos("BOVE",callpoint_id_str$,5);rem Before Table Overview
			break
			case fnstr_pos("BPRI",callpoint_id_str$,5);rem Before Previous Record
			break
			case fnstr_pos("BPRK",callpoint_id_str$,5);rem Before Prev Record Key
			break
			case fnstr_pos("BRCO",callpoint_id_str$,5);rem Before Record Copy
			break
			case fnstr_pos("BREA",callpoint_id_str$,5);rem Before Record Read
			break
			case fnstr_pos("BREC",callpoint_id_str$,5);rem Before New Record
			break
			case fnstr_pos("BREM",callpoint_id_str$,5);rem Before Record Removal
			break
			case fnstr_pos("BSAV",callpoint_id_str$,5);rem Before Detail Save
			break
			case fnstr_pos("BSHO",callpoint_id_str$,5);rem Before Window Show

            rem --- Open/Lock files

                files=21,begfile=1,endfile=10
                dim files$[files],options$[files],chans$[files],templates$[files]
                files$[1]="ARS_PARAMS";rem --- "ARS_PARAMS"..."ads-01"
                files$[2]="ARE_INVHDR";rem --- "are-05"
                files$[3]="ARE_INVDET";rem --- "are-15"
                files$[4]="ARM_CUSTMAST";rem --- "arm-01"
                files$[5]="ARM_CUSTDET";rem --- "arm-02"
                files$[6]="ARC_TERMCODE";rem --- "arm-10" (A)
                files$[7]="ARC_DISTCODE";rem --- "arm-10 (D)
                files$[8]="ARS_MTDCASH";rem --- "ars-10",ids$[7]="C"
                files$[9]="ART_INVHDR";rem --- "art-01"
                files$[10]="ART_INVDET";rem --- "art-11"
                rem --- are-15 used to get open on 2 channels, but looks like it won't be necessary in v8.CAH
                rem --- files$[11]="ARE_INVDET";rem --- "are-15" -- open on 2 channels

                for wkx=begfile to endfile
                    options$[wkx]="OTA"
                next wkx
                rem --- options$[11]="NA";rem --- force are-15 open on 2nd device

                call pgmdir$+"adc_open_tables.aon",begfile,endfile,files$[all],options$[all],
:                                   chans$[all],templates$[all],table_chans$[all],batch,status$

                if status$<>"" goto std_exit
                ads01_dev=num(chans$[1])

            rem --- Retrieve miscellaneous templates

                files=2,begfile=1,endfile=files
                dim ids$[files],templates$[files]
                ids$[1]="ars-01A"
                ids$[2]="gls-01A"
                call pgmdir$+"adc_template.aon",begfile,endfile,ids$[all],templates$[all],status
                if status goto std_exit

            rem --- Dimension miscellaneous string templates

                dim ars01a$:templates$[1],gls01a$:templates$[2]
                dim aon_tpl$:"firm_id:c(2),glint:C(1),glyr:C(4),glper:C(2),glworkfile:C(16),totqty:C(15),totamt:C(15)";rem --- used to pass 'stuff' to/from cpt
                aon_tpl.firm_id$=firm_id$

            rem --- Additional File Opens

                gl$="N"
                status=0
                call pgmdir$+"glc_ctlcreate.aon",err=*next,source$,"AR",glw11$,gl$,status;rem --- source$?
                if status<>0 goto std_exit
                aon_tpl.glint$=gl$
                aon_tpl.glworkfile$=glw11$
                rem --- gl$="Y";rem --- temp for testing.CAH
                if gl$="Y"
                    files=21,begfile=20,endfile=21
                    dim files$[files],options$[files],chans$[files],templates$[files]
                    files$[20]="GLM_ACCT",options$[20]="OTA";rem --- "glm-01"
                    files$[21]=glw11$,options$[21]="OTAS";rem --- s means no err if tmplt not found
                    rem --- will need alias name, not disk name, when opening work file
                    rem --- will also need option to lock/clear file; not using in this pgm for now, so bypassing.CAH
                    rem --- old pgm set options$[11]?  doesn't make sense, s/b options$[21]="C"?

                call pgmdir$+"adc_open_tables.aon",begfile,endfile,files$[all],options$[all],
:                   chans$[all],templates$[all],table_chans$[all],batch,status$

                    if status$<>"" goto std_exit

                else
                    rem --- this logic creates/sets window object w! to child window, then creates/sets control object
                    rem --- to control w/ ID 5900, (c!.getName()should be the grd_ARE_INVDET)
                    rem --- finally, sets first (0) column as not editable (0) (the GL acct#)
                    w!=rdForm!.getChildWindow(1109)
                    c!=w!.getControl(5900)
                    c!.setColumnEditable(0,0)

                endif

            rem --- Retrieve parameter data - not keeping any of it here, just make sure params exist
               
                ars01a_key$=firm_id$+"AR00"
                find record (ads01_dev,key=ars01a_key$,err=std_missing_params) ars01a$

                gls01a_key$=firm_id$+"GL00"
                find record (ads01_dev,key=gls01a_key$,err=std_missing_params) gls01a$ 
            
			break

			case fnstr_pos("BWAR",callpoint_id_str$,5);rem Before Write Array
			break
			case fnstr_pos("BWRI",callpoint_id_str$,5);rem Before Record Write
			break
			case default
			break
		swend
	endif

rem --- Route column callpoint to correct subroutine (Column callpoint if callpoint_var$<>null)
rem		Column Events:
rem			AINP-After Column Input
rem			AINQ-After Column Inquiry
rem			AVAL-After Column Validation
rem			BINP-Before Column Input
rem			BINQ-Before Column Inquiry

	if cvs(callpoint_var$,2)<>""
		switch fnstr_pos(callpoint_var$,callpoint_var_str$,40)
			case fnstr_pos("ARE_INVHDR.AR_INV_NO",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)
					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break
			case fnstr_pos("ARE_INVHDR.CUSTOMER_ID",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)
                        if cvs(callpoint_data$,2)<>"" and rec_data$[fnstr_pos("ARE_INVHDR.CUSTOMER_ID",rec_data$[0,0],40),0]<>
:							rec_data$[fnstr_pos("ARE_INVHDR.CUSTOMER_ID",rec_data$[0,0],40),1]
								rem --- force current and original cust ID same, so we skip this routine on later validation sweep
								rec_data$[fnstr_pos("ARE_INVHDR.CUSTOMER_ID",rec_data$[0,0],40),1]=
:									rec_data$[fnstr_pos("ARE_INVHDR.CUSTOMER_ID",rec_data$[0,0],40),0]
								cust_key$=fnget_rec$("ARE_INVHDR.FIRM_ID")+callpoint_data$
								gosub disp_cust_addr
								callpoint.callpoint_stat$="REFRESH"
								gosub check_outstanding_inv
								if os_inv$="Y"
									rd_msg_id$="AR_INV_ADJ"
									dim rd_msg_tokens$[1]
									rd_msg_opt$=""
									gosub disp_message
									if rd_msg_opt$="Y"
										rec_data$[fnstr_pos("ARE_INVHDR.SIM_INV_TYPE",rec_data$[0,0],40),0]="A"
										rec_data$[fnstr_pos("ARE_INVHDR.SIM_INV_TYPE",rec_data$[0,0],40),1]="A"
										callpoint.callpoint_stat$="MODIFIED-REFRESH"
									else
										callpoint.callpoint_stat$="CLEAR-NEW"
									endif
								endif                            
                        endif
					break
					case fnstr_pos("AVEC",callpoint_id_str$,5)
					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break
			case fnstr_pos("ARE_INVHDR.AR_DIST_CODE",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)
					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break
			case fnstr_pos("ARE_INVHDR.FIRM_ID",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)
					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break
			case fnstr_pos("ARE_INVHDR.INV_DATE",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)

						gl$=aon_tpl.glint$
						invdate$=callpoint_data$        
						if gl$="Y" 
							call pgmdir$+"glc_datecheck.aon",invdate$,"Y",per$,yr$,status
							if status>99
								callpoint.callpoint_stat$="ABORT"
							else
								aon_tpl.glyr$=yr$
								aon_tpl.glper$=per$
							endif
						endif

					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break
			case fnstr_pos("ARE_INVHDR.RESERVED_STR",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)
					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break
			case fnstr_pos("ARE_INVHDR.RESERVED_STR",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)
					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break
			case fnstr_pos("ARE_INVHDR.SEQUENCE_000",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)
					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break
			case fnstr_pos("ARE_INVHDR.SIM_INV_TYPE",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)
					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break
			case fnstr_pos("ARE_INVHDR.AR_TERMS_CODE",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)
					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break
			case fnstr_pos("ARE_INVDET.UNITS",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)
                      
                        newqty=num(callpoint_data$)                       
                        unit_price=num(fnget_rec$("ARE_INVDET.UNIT_PRICE"))               
                        new_ext_price=newqty*unit_price

                        rec_data$[fnstr_pos("ARE_INVDET.EXT_PRICE",rec_data$[0,0],40),0]=str(new_ext_price)
                        callpoint.callpoint_stat$="MODIFIED-REFRESH"

					break
					case fnstr_pos("AVEC",callpoint_id_str$,5)

                        gosub calc_grid_tots
                        gosub disp_totals

					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break
			case fnstr_pos("ARE_INVDET.UNIT_PRICE",callpoint_var_str$,40)
				switch fnstr_pos(callpoint_id$,callpoint_id_str$,5)
					case fnstr_pos("AINP",callpoint_id_str$,5)
					break
					case fnstr_pos("AINQ",callpoint_id_str$,5)
					break
					case fnstr_pos("AVAL",callpoint_id_str$,5)

                        new_unit_price=num(callpoint_data$)
                        units=num(fnget_rec$("ARE_INVDET.UNITS"))               
                        new_ext_price=units*new_unit_price

                        rec_data$[fnstr_pos("ARE_INVDET.EXT_PRICE",rec_data$[0,0],40),0]=str(new_ext_price)
                        callpoint.callpoint_stat$="MODIFIED-REFRESH"
                       
					break
					case fnstr_pos("AVEC",callpoint_id_str$,5)
 
                        gosub calc_grid_tots
                        gosub disp_totals
                       
					break
					case fnstr_pos("BINP",callpoint_id_str$,5)
					break
					case fnstr_pos("BINQ",callpoint_id_str$,5)
					break
				swend
			break

		swend
	endif

rem --- All done

	goto std_exit

open_tables:rem --- Open Tables

	call stbl("+DIR_PGM")+"rdc_open_tables.aon",
:		rd_open_beg,
:		rd_open_end,
:		rd_open_tables$[all],
:		rd_open_opts$[all],
:		rd_open_chans$[all],
:		rd_open_tpls$[all],
:		rd_table_chans$[all],
:		rd_open_batch,
:		rd_open_status$

	if rd_open_status$<>""
		rd_msg_id$="ENTRY_OPEN_ERROR"
		dim rd_msg_tokens$[1]
			rd_msg_tokens$[1]=rd_open_status$
		gosub disp_message
		goto std_exit
	endif

	return

disp_message:rem --- Display Message Dialog

	call stbl("+DIR_PGM")+"adc_message.aon",rd_msg_id$,rd_msg_tokens$[all],rd_msg_opt$,rd_table_chans$[all]

	return

calc_grid_tots:

        recVect!=rdGridVect!.getItem(0)
        dim gridrec$:dtlg_param$[1,3]
        numrecs=recVect!.size()
        if numrecs>0
            for reccnt=0 to numrecs-1
                gridrec$=recVect!.getItem(reccnt)
                tqty=tqty+num(gridrec.units$)
                tamt=tamt+num(gridrec.ext_price$)
            next reccnt

            aon_tpl.totqty$=str(tqty),aon_tpl.totamt$=str(tamt)
        endif
    return

disp_totals:

    rem --- get context and ID of total quantity/amount display controls, and redisplay w/ amts from calc_tots
    rem --- from w/in grid, so setting hrec_data$ doesn't work, as refresh only works on grid?
    rem --- hrec_data$[fnstr_pos("<<DISPLAY>>.TOT_QTY",hrec_data$[0,0],40),0]=str(tqty)
    rem --- hrec_data$[fnstr_pos("<<DISPLAY>>.TOT_AMT",hrec_data$[0,0],40),0]=str(tamt)
    
    ctlContext=num(fngetv_hattr$("<<DISPLAY>>.TOT_QTY","CTLC"))
    ctlID=num(fngetv_hattr$("<<DISPLAY>>.TOT_QTY","CTLI"))
    tqty!=rdSysGUI!.getWindow(ctlContext).getControl(ctlID)
    tqty!.setValue(num(aon_tpl.totqty$))

    ctlContext=num(fngetv_hattr$("<<DISPLAY>>.TOT_AMT","CTLC"))
    ctlID=num(fngetv_hattr$("<<DISPLAY>>.TOT_AMT","CTLI"))
    tamt!=rdSysGUI!.getWindow(ctlContext).getControl(ctlID)
    tamt!.setValue(num(aon_tpl.totamt$))

    return

disp_cust_addr:

    tablepos=pos("ARM_CUSTMAST"=table_chans$[0,0],20)
    arm_custmast_dev=num(table_chans$[0,0](tablepos+17,3))
    dim arm01a$:table_chans$[int(tablepos/20)+1,0]
    readrecord(arm_custmast_dev,key=cust_key$,err=std_error)arm01a$
    rec_data$[fnstr_pos("<<DISPLAY>>.CUST_ADDR1",rec_data$[0,0],40),0]=arm01a.addr_line_1$
    rec_data$[fnstr_pos("<<DISPLAY>>.CUST_ADDR2",rec_data$[0,0],40),0]=arm01a.addr_line_2$               
    rec_data$[fnstr_pos("<<DISPLAY>>.CUST_CTST",rec_data$[0,0],40),0]=cvs(arm01a.city$,2)+
:       ", "+arm01a.state_code$
    rec_data$[fnstr_pos("<<DISPLAY>>.CUST_ZIP",rec_data$[0,0],40),0]=arm01a.zip_code$

    rem --- also retrieve default dist/terms codes for customer

	if cvs(fnget_rec$("ARE_INVHDR.AR_DIST_CODE"),3)=""
        tablepos=pos("ARM_CUSTDET"=table_chans$[0,0],20)
        arm_custdet_dev=num(table_chans$[0,0](tablepos+17,3))
        dim arm02a$:table_chans$[int(tablepos/20)+1,0]
        arm02a.firm_id$=arm01a.firm_id$,arm02a.customer_id$=arm01a.customer_id$,arm02a.ar_type$="  "
        readrecord(arm_custdet_dev,key=arm02a.firm_id$+arm02a.customer_id$+arm02a.ar_type$,err=*next)arm02a$
        rec_data$[fnstr_pos("ARE_INVHDR.AR_DIST_CODE",rec_data$[0,0],40),0]=arm02a.ar_dist_code$
	endif
	if cvs(fnget_rec$("ARE_INVHDR.AR_TERMS_CODE"),3)=""
        tablepos=pos("ARM_CUSTDET"=table_chans$[0,0],20)
        arm_custdet_dev=num(table_chans$[0,0](tablepos+17,3))
        dim arm02a$:table_chans$[int(tablepos/20)+1,0]
        arm02a.firm_id$=arm01a.firm_id$,arm02a.customer_id$=arm01a.customer_id$,arm02a.ar_type$="  "
        readrecord(arm_custdet_dev,key=arm02a.firm_id$+arm02a.customer_id$+arm02a.ar_type$,err=*next)arm02a$
        rec_data$[fnstr_pos("ARE_INVHDR.AR_TERMS_CODE",rec_data$[0,0],40),0]=arm02a.ar_terms_code$
	endif

    return

check_outstanding_inv:

    os_inv$="N"
    tablepos=pos("ART_INVHDR"=table_chans$[0,0],20)
    art_invhdr_dev=num(table_chans$[0,0](tablepos+17,3))
    dim art01a$:table_chans$[int(tablepos/20)+1,0]
    readrecord(art_invhdr_dev,key=firm_id$+"  "+fnget_rec$("ARE_INVHDR.CUSTOMER_ID")+
:       fnget_rec$("ARE_INVHDR.AR_INV_NO")+"00",err=*next)art01a$;os_inv$="Y"
    return
    
    
rem --- Functions

	def fnstr_pos(tmp0$,tmp1$,tmp1)=int((pos(tmp0$=tmp1$,tmp1)+tmp1-1)/tmp1)
	def fngett_attr$(att0$)=attr_tbl$[fnstr_pos(att0$,attr_def_tbl$[0,0],5)]
	def fngetc_attr$(att0,att0$)=attr_col$[att0,fnstr_pos(att0$,attr_def_col$[0,0],5)]
	def fngetv_attr$(att0$,att1$)=attr_col$[fnstr_pos(att0$,attr_col$[0,1],40),fnstr_pos(att1$,attr_def_col$[0,0],5)]
	def fnget_rec$(att0$)=rec_data$[fnstr_pos(att0$,rec_data$[0,0],40),0]
	def fngetv_hattr$(att0$,att1$)=hattr_col$[fnstr_pos(att0$,hattr_col$[0,1],40),fnstr_pos(att1$,hattr_col$[0,0],5)]


rem --- Format zip/postal code

    def fnzipcode$(q$)=fill(10,cvs(q$(1,3)+fill(pos("9"<q$(1,5))>0)+q$(4,2)+
:                      fill(ABS(pos("A">=q$(1,6))>0)-pos("0">q$(6,4))>0,"-")+
:                      q$(6,4)+fill(10),16))

rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5):"00000"),
:                                   str(err:"000"),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

	rd_err_text$=""
	if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
	pgmdir$=stbl("+DIR_PGM",err=std_error_exit)
	call pgmdir$+"adc_error.aon",err=std_error_exit,pgm(-2),str(tcb(5):"00000"),str(err:"000"),rd_err_text$,rd_err_act$
	if pos("EXIT"=rd_err_act$) goto std_error_exit
	if pos("ESCAPE"=rd_err_act$) seterr 0;setesc 0
	if pos("RETRY"=rd_err_act$) retry

std_error_exit:
	
	master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
	sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
	dim sysinfo$:sysinfo_template$
	sysinfo$=stbl("+SYSINFO",err=std_error_release)
	if cvs(sysinfo.user_id$,2)=master_user$ escape
	
std_error_release:

	status=999
	if pgm(-1)<>pgm(-2) exit 
	release

rem #endinclude std_error.src

rem #include std_exit.src

std_exit: rem --- Standard called program exit (01Mar2006)

	exit

rem #endinclude std_exit.src

	end

