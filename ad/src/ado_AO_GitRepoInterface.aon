rem ==========================================================================
rem --- ado_AO_GitRepoInterface.aon 
rem --- AO_GitRepoInterface class (GitRepoInterface superclass)
rem --- Superclass used to synchronize specified sync/*.xml files.
rem --- 
rem --- Copyright BASIS International Ltd.  All Rights Reserved.
rem ==========================================================================

rem /**
rem  * This class uses JGit to interface with Addon's Git repository to perform
rem  * tasks needed during upgrades and updates.
rem  */

    use java.io.File
    use java.lang.reflect.Array
    use java.nio.charset.StandardCharsets
    use java.util.HashMap
    use java.util.TreeSet

    use org.eclipse.jgit.api.CheckoutCommand.Stage
    use org.eclipse.jgit.api.CherryPickResult.CherryPickStatus
    use org.eclipse.jgit.api.CreateBranchCommand.SetupUpstreamMode
    use org.eclipse.jgit.api.Git
    use org.eclipse.jgit.lib.AnyObjectId
    use org.eclipse.jgit.lib.ObjectId
    use org.eclipse.jgit.lib.Repository
    use org.eclipse.jgit.revwalk.RevCommit
    use org.eclipse.jgit.revwalk.RevWalk
    use org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider
    use org.eclipse.jgit.treewalk.CanonicalTreeParser
    use org.eclipse.jgit.treewalk.TreeWalk

    
    class public AO_GitRepoInterface
        field public BBjString AonDir$
        field public BBjString Branch$
        field public BBjString LocalBranch$
        field public BBjString LocalRepo$
        field public BBjString ReleaseTag$
        field public BBjString RemoteBranch$

        field protected Git git!
        field protected Repository repository!
        field protected UsernamePasswordCredentialsProvider credentials!
        
        rem /**
        rem  * Constructor.
        rem  * Clones Git repository to specified location if one does not already exist there.
        rem  *
        rem  * @param BBjString aonDir$
        rem  */
        method public AO_GitRepoInterface(BBjString aonDir$)
            seterr GitRepoInterface_error
            #AonDir$=aonDir$
            #LocalRepo$=#AonDir$+"/.git"
            #credentials!=new UsernamePasswordCredentialsProvider("username","password")

            rem --- Get Git repository
            gitDir! = new File(#LocalRepo$)
            if !gitDir!.exists() then
                rem --- Clone Git repository to specified location
                gitURI$="https://git.basis.com/Addon/Addon.git"
    
                cloneCmd!=Git.cloneRepository()
                cloneCmd!.setCredentialsProvider(#credentials!)
                cloneCmd!.setURI(gitURI$).setDirectory(new File(aonDir$)).setCloneAllBranches(1)
                cloneCmd!.call()
            endif
            #git!=Git.open(new File(#LocalRepo$))
            
            rem --- Initializations
            #repository!=#git!.getRepository()
            #Branch$=#repository!.getBranch()
            branchName$=#Branch$(1+pos("/"=#Branch$))
            #LocalBranch$="heads/"+branchName$
            #RemoteBranch$="remotes/origin/"+branchName$
            #ReleaseTag$="refs/tags/"+branchName$+"_Release"
            
            methodret
            
GitRepoInterface_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Checkout (i.e. switch to) specified branch in repository. 
        rem  * 
        rem  * @param BBjString branchName$ -- branch name
        rem  *
        rem  * @return BBjString status$ -- OK - Checkout completely normal
        rem  *                              ERROR - An Exception occurred during checkout
        rem  *                              CONFLICTS - Checkout has not completed because of checkout conflicts
        rem  *                              NONDELETED - Checkout has completed, but some files could not be deleted
        rem  *                              NOT_TRIED - The call() method has not yet been executed
        rem  */
        method public BBjString checkoutBranch(BBjString branchName$)
            seterr checkoutBranch_error
            status$="OK"

            rem --- Is this already the current branch?
            if branchName$<>#repository!.getBranch() then
                if #repository!.resolve("heads/"+branchName$)=null() then
                    rem --- Not currently a local branch, so create it.
                    checkoutCmd!=#git!.checkout().setName("heads/"+branchName$).setUpstreamMode(SetupUpstreamMode.TRACK).setStartPoint("remotes/origin/"+branchName$)
                    checkoutCmd!=checkoutCmd!.setCreateBranch(1)
                else
                    rem --- Already a local branch
                    checkoutCmd!=#git!.checkout().setName("heads/"+branchName$)
                endif
                checkoutCmd!.call()
                results!=checkoutCmd!.getResult()
                status$=results!.getStatus().toString()
    
                rem --- Re-initialize
                #Branch$=#repository!.getBranch()
                #LocalBranch$="heads/"+branchName$
                #RemoteBranch$="remotes/origin/"+branchName$
                #ReleaseTag$="refs/tags/"+branchName$+"_Release"
            endif

            methodret status$
           
checkoutBranch_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Cherry picks Git repository commit given as a RevCommit object. 
        rem  * 
        rem  * @param RevCommit commit! -- Git repository commits
        rem  *
        rem  * @return HashMap failures! --  key: path
        rem  *                             value: failure reason
        rem  */
        method public HashMap cherryPick(RevCommit commit!)
            seterr cherryPick_error
            failures!=new HashMap()

            cherryPickCmd!=#git!.cherryPick()
            cherryPickCmd!.include(commit!)
            result!=cherryPickCmd!.call()

            rem --- Check for conflicts that are due to a bar/*.xml file, and resolve them by accepting ours 
            switch (result!.getStatus()) 
                case CherryPickStatus.OK
                    break
                case CherryPickStatus.CONFLICTING
                    status!=#git!.status().call()
                    conflictingFiles!=status!.getConflicting()
                    fileIter!=conflictingFiles!.iterator()
                    while (fileIter!.hasNext())
                        fileName!=cast(BBjString,fileIter!.next())
                        if (fileName!.matches("data/bar/.*\.xml")) then  
                            rem --- Choose ours for bar/*.xml file conflicts
                            checkoutCmd!=#git!.checkout()
                            checkoutCmd!.setStage(Stage.OURS)
                            checkoutCmd!.addPath(fileName!)
                            checkoutCmd!.call()
                            #git!.add().addFilepattern(fileName!).call()
                        endif
                    wend
                    break
                case CherryPickStatus.FAILED
                    failures!=result!.getFailingPaths()
                    break
            swend 
            
            methodret failures!
           
cherryPick_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Free resources associated with this instance. 
        rem  */
        method public void closeInterface()
            seterr closeInterface_error

            #repository!.close()
            #git!.close()
            
            methodret
           
closeInterface_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Returns the commit Object ID for a given branch or tag name. 
        rem  * 
        rem  * @param BBjString branch_tag$ -- branch or tag name
        rem  *
        rem  * @return ObjectId commitId!
        rem  */
        method public ObjectId getCommitId(BBjString branch_tag$)
            seterr getCommitID_error
            commitId!=null()

            revWalk!=new RevWalk(#repository!)
            commit!=#repository!.resolve(branch_tag$)
            if commit!<>null() then
                revObject!=revWalk!.peel(revWalk!.parseAny(commit!))
                commitId!=revObject!.getId()
            endif
            
            methodret commitId!
           
getCommitID_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Builds list of commits made from since$ through until$. 
        rem  * 
        rem  * @param BBjString since$ -- branch or tag name since
        rem  * @param BBjString until$ -- branch or tag name until
        rem  *
        rem  * @return java.util.List commits!
        rem  */
        method public java.util.List getCommits(BBjString since$, BBjString until$)
            seterr getCommits_error
            commits!=null()

            untilId!=#getCommitId(until$)
            sinceId!=#getCommitId(since$)
            if untilId!<>null() and sinceId!<>null() then
                logCmd!=#git!.log().addRange(untilId!,sinceId!)
                revCommits!=logCmd!.call()
                commits!=cast(java.util.List,java.util.stream.StreamSupport.stream(revCommits!.spliterator(),0).collect(java.util.stream.Collectors.toList()))
            endif
            
            methodret commits!
           
getCommits_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Builds Vector of file names for conflicts in local Git repository. 
        rem  *
        rem  * @return BBjVector conflicts!
        rem  */
        method public BBjVector getConflicts()
            seterr getConflicts_error
            conflicts!=BBjAPI().makeVector()

            status!=#git!.status().call()
            conflictingFiles!=status!.getConflicting()
            conflicts!.addAll(conflictingFiles!)
            
            methodret conflicts!
           
getConflicts_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 
    
        rem /**
        rem  * Builds Vector of local commits made from since$ through until$ that 
        rem  * were NOT pushed to the remote repository. 
        rem  * 
        rem  * @param BBjString since$ -- branch or tag name since
        rem  * @param BBjString until$ -- branch or tag name until
        rem  *
        rem  * @return BBjVector filteredLocalCommits!
        rem  */
        method public BBjVector getLocalCommits(BBjString since$, BBjString until$)
            seterr getLocalCommits_error
            filteredLocalCommits!=BBjAPI().makeVector()
            tmpVect!=BBjAPI().makeVector()

            remoteCommits!=#getCommits(#RemoteBranch$,until$)
            localCommits!=#getCommits(since$,until$)
            
            if remoteCommits!<>null() and localCommits!<>null()
                localCommits!.removeAll(remoteCommits!)
                commitIter!=localCommits!.iterator()
                while (commitIter!.hasNext())
                    commit!=commitIter!.next()
                    filteredLocalCommits!.addItem(commit!)
                    rem --- Once we encounter a commit that has more than one parent, we have a merge result, 
                    rem --- so grab the merge result, which has all our previous changes and stop here. 
                    if (commit!.getParentCount()>=2) then 
                        break
                    endif   
                wend
            endif
            
            rem -- Sort commits so they are from the first/earliest to the last/latest.
            if filteredLocalCommits!.size()>0 then
                for i=filteredLocalCommits!.size()-1 to 0 step -1
                    tmpVect!.addItem(filteredLocalCommits!.getItem(i))
                next i
                filteredLocalCommits!=tmpVect!
            endif
            
            methodret filteredLocalCommits!
           
getLocalCommits_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 
    
        rem /**
        rem  * Builds Tree of bar/*.xml files in a Vector of filtered local commits. 
        rem  * 
        rem  * @param BBjVector localCommits! -- filtered local commits
        rem  *
        rem  * @return TreeSet localCommittedXmls!
        rem  */
        method public TreeSet getLocalCommittedXmls(BBjVector localCommits!)
            seterr getLocalCommittedXmls_error
            localCommittedXmls!=new TreeSet()

            commitIter!=localCommits!.iterator()
            while commitIter!.hasNext()
                commit!=commitIter!.next()
                prevCommit!=commit!.getParent(commit!.getParentCount()-1)
    
                treeParser!=new CanonicalTreeParser(null(), #repository!.newObjectReader(), commit!.getTree().getId())
                prevTreeParser!=new CanonicalTreeParser(null(), #repository!.newObjectReader(), prevCommit!.getTree().getId())

                diffCmd! = #git!.diff()
                diffCmd!.setNewTree(treeParser!)
                diffCmd!.setOldTree(prevTreeParser!)
                diffs!=diffCmd!.call()

                diffIter!=diffs!.iterator()
                while diffIter!.hasNext()
                    diff!=diffIter!.next()
                    if diff!.getNewPath().matches("^data/bar/.*\.xml$") then 
                        localCommittedXmls!.add(diff!.getNewPath())
                    endif
                wend
            wend
            
            methodret localCommittedXmls!
           
getLocalCommittedXmls_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 
    
        rem /**
        rem  * Builds Tree of bar/*.xml files committed from since$ through until$ that 
        rem  * were NOT pushed to the remote repository. 
        rem  * 
        rem  * @param BBjString since$ -- branch or tag name since
        rem  * @param BBjString until$ -- branch or tag name until
        rem  *
        rem  * @return TreeSet localCommittedXmls!
        rem  */
        method public TreeSet getLocalCommittedXmls(BBjString since$, BBjString until$)
            seterr getLocalCommittedXmls2_error

            localCommits!=#getLocalCommits(since$, until$)
            localCommittedXmls!=#getLocalCommittedXmls(localCommits!)
            
            methodret localCommittedXmls!
           
getLocalCommittedXmls2_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Returns the contents of the specified file from the remote repository. 
        rem  * 
        rem  * @param BBjString filePath$ -- file name, including path within the repository
        rem  *
        rem  * @return BBjString fileContent$
        rem  */
        method public BBjString getRemoteFileContent(BBjString filePath$)
            seterr getRemoteFileContent_error

            commit!=#repository!.resolve("refs/remotes/origin/"+#Branch$+"^{tree}")
            commitArray!=Array.newInstance(commit!.getClass(),1)
            Array.set(commitArray!,0,commit!)

            rem --- Create original version of modified bar/*.xml files in list.
            treeWalk!=TreeWalk.forPath(#repository!,filePath$,commitArray!)
            reader!=#repository!.newObjectReader()
            loader!=reader!.open(treeWalk!.getObjectId(0))
            fileContent$=new String(loader!.getBytes(),StandardCharsets.UTF_8)

            reader!.close()
            treeWalk!.close()
            
            methodret fileContent$
           
getRemoteFileContent_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Get Git RevCommit object from given BBjString. 
        rem  * 
        rem  * @param BBjString commit$! -- example:
        rem  *                              commit 1ce0c5f8e453278e12f10795164613693d09d218 1590167270 ----sp
        rem  *
        rem  * @return RevCommit revCommit!
        rem  */
        method public RevCommit getRevCommit(BBjString commit$)
            seterr getRevCommit_error
            revCommit!=null()
            
            rem --- Reduce commit string down to just the hex characters
            hexChars$=commit$
            if pos("commit "=hexChars$) then hexChars$=hexChars$(pos("commit "=hexChars$)+len("commit "))
            if pos(" ----sp"=hexChars$) then hexChars$=hexChars$(1,pos(" ----sp"=hexChars$)-1)
            if pos(" "=hexChars$) then hexChars$=hexChars$(1,pos(" "=hexChars$)-1)

            if ObjectId.isId(hexChars$) then
                objectId!=ObjectId.fromString(hexChars$)
                logCmd!=#git!.log().add(objectId!).setMaxCount(1)
                revCommits!=logCmd!.call()
                commits!=cast(java.util.List,java.util.stream.StreamSupport.stream(revCommits!.spliterator(),0).collect(java.util.stream.Collectors.toList()))
                
                commitsIter!=commits!.iterator()
                while commitsIter!.hasNext()
                    revCommit!=commitsIter!.next()
                wend
            endif
                        
            methodret revCommit!
           
getRevCommit_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Get Vector of uncommitted staged changes in the local repository has . 
        rem  *
        rem  * @return BBjVector stagedChanges!
        rem  */
        method public BBjVector getStagedChanges()
            seterr getStagedChanges_error
            stagedChanges!=BBjAPI().makeVector()

            diffCmd!=#git!.diff().setCached(1)
            if diffCmd!<>null() then
                diffIter!=diffCmd!.call().iterator()
                while diffIter!.hasNext()
                    diffEntry!=diffIter!.next()
                    stagedChanges!.addItem(diffEntry!.getNewPath())
                wend
            endif
            
            methodret stagedChanges!
           
getStagedChanges_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Get Vector of uncommitted unstaged changes in the local repository. 
        rem  *
        rem  * @return BBjVector unstagedChanges!
        rem  */
        method public BBjVector getUnstagedChanges()
            seterr getUnstagedChanges_error
            unstagedChanges!=BBjAPI().makeVector()

            diffCmd!=#git!.diff()
            if diffCmd!<>null() then
                diffIter!=diffCmd!.call().iterator()
                while diffIter!.hasNext()
                    diffEntry!=diffIter!.next()
                    unstagedChanges!.addItem(diffEntry!.getNewPath())
                wend
            endif
            
            methodret unstagedChanges!
           
getUnstagedChanges_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Refresh (pull) the local repository. 
        rem  */
        method public void pullRepository()
            seterr pullRepository_error

            pullCmd!=#git!.pull()
            pullCmd!.setCredentialsProvider(#credentials!)
            pullCmd!.call()
            
            methodret
           
pullRepository_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 
        
        rem /**
        rem  * Method for testing. 
        rem  */
        method public void testPrint()

            print "#Branch$=",#Branch$
            print "#LocalBranch$=",#LocalBranch$
            print "#RemoteBranch$=",#RemoteBranch$
            print "#ReleaseTag$=",#ReleaseTag$

            localCommits!=#getLocalCommits(#LocalBranch$,#ReleaseTag$)
            print "localCommits!=",localCommits!

            localCommittedXmls!=#getLocalCommittedXmls(localCommits!)
            print "localCommittedXmls!=",localCommittedXmls!
      
            methodret
        methodend

classend
