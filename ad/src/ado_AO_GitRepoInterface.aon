rem ==========================================================================
rem --- ado_AO_GitRepoInterface.aon 
rem --- AO_GitRepoInterface class (GitRepoInterface superclass)
rem --- Superclass used to interface with JGit.
rem --- 
rem --- Copyright BASIS International Ltd.  All Rights Reserved.
rem ==========================================================================

rem /**
rem  * This class uses JGit to interface with Addon's Git repository to perform
rem  * tasks needed during upgrades and updates.
rem  */

    use ::ado_GitRepoInterface.aon::FixedIssuesReader

    use java.io.ByteArrayOutputStream
    use java.io.File
    use java.lang.reflect.Array
    use java.nio.charset.StandardCharsets
    use java.text.SimpleDateFormat
    use java.util.Date
    use java.util.HashMap
    use java.util.TreeSet
    use java.util.ArrayList
    use java.util.Arrays
    use java.util.Iterator

    use org.eclipse.jgit.api.CheckoutCommand
    use org.eclipse.jgit.api.CheckoutCommand.Stage
    use org.eclipse.jgit.api.CherryPickResult.CherryPickStatus
    use org.eclipse.jgit.api.ResetCommand
    use org.eclipse.jgit.api.ResetCommand.ResetType
    use org.eclipse.jgit.api.CreateBranchCommand.SetupUpstreamMode
    use org.eclipse.jgit.api.Git
    use org.eclipse.jgit.diff.DiffEntry
    use org.eclipse.jgit.diff.DiffFormatter
    use org.eclipse.jgit.lib.AnyObjectId
    use org.eclipse.jgit.lib.Constants
    use org.eclipse.jgit.lib.ObjectId
    use org.eclipse.jgit.lib.ObjectReader
    use org.eclipse.jgit.lib.Repository
    use org.eclipse.jgit.lib.Ref
    use org.eclipse.jgit.revwalk.RevCommit
    use org.eclipse.jgit.revwalk.RevWalk
    use org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider
    use org.eclipse.jgit.treewalk.CanonicalTreeParser
    use org.eclipse.jgit.treewalk.FileTreeIterator
    use org.eclipse.jgit.treewalk.TreeWalk

rem /**
rem  * This class uses JGit to interface with Addon's Git repository to perform
rem  * tasks needed during upgrades and updates.
rem  */
    
    class public AO_GitRepoInterface
        field public BBjString AonDir$
        field public BBjString Branch$
        field public BBjString LocalBranch$
        field public BBjString LocalRepo$
        field public BBjString ReleaseTag$
        field public BBjString RemoteBranch$

        field protected Git git!
        field protected Repository repository!
        field protected UsernamePasswordCredentialsProvider credentials!
        
        field protected FixedIssuesReader fixedIssuesReader!
        
        rem /**
        rem  * Constructor.
        rem  * Clones Git repository to specified location if one does not already exist there.
        rem  *
        rem  * @param BBjString aonDir$
        rem  */
        method public AO_GitRepoInterface(BBjString aonDir$)
            seterr GitRepoInterface_error
            #AonDir$=aonDir$
            #LocalRepo$=#AonDir$+"/.git"
            #credentials!=new UsernamePasswordCredentialsProvider("username","password")

            rem --- Get Git repository
            gitDir! = new File(#LocalRepo$)
            if !gitDir!.exists() then
                rem --- Clone Git repository to specified location
                gitURI$="https://git.basis.com/Addon/Addon.git"
    
                cloneCmd!=Git.cloneRepository()
                cloneCmd!.setCredentialsProvider(#credentials!)
                cloneCmd!.setURI(gitURI$).setDirectory(new File(aonDir$)).setCloneAllBranches(1)
                cloneCmd!.call()
            endif
            #git!=Git.open(new File(#LocalRepo$))
            
            rem --- Initializations
            #repository!=#git!.getRepository()
            #Branch$=#repository!.getBranch()
            branchName$=#Branch$(1+pos("/"=#Branch$))
            #LocalBranch$="heads/"+branchName$
            #RemoteBranch$="remotes/origin/"+branchName$
            #ReleaseTag$="refs/tags/"+branchName$+"_Release"
            
            methodret
            
GitRepoInterface_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Checkout (i.e. switch to) specified branch in repository. 
        rem  * 
        rem  * @param BBjString branchName$ -- branch name
        rem  *
        rem  * @return BBjString status$ -- OK - Checkout completely normal
        rem  *                              ERROR - An Exception occurred during checkout
        rem  *                              CONFLICTS - Checkout has not completed because of checkout conflicts
        rem  *                              NONDELETED - Checkout has completed, but some files could not be deleted
        rem  *                              NOT_TRIED - The call() method has not yet been executed
        rem  */
        method public BBjString checkoutBranch(BBjString branchName$)
            seterr checkoutBranch_error
            status$="OK"

            rem --- Is this already the current branch?
            if branchName$<>#repository!.getBranch() then
                if #repository!.resolve("heads/"+branchName$)=null() then
                    rem --- Not currently a local branch, so create it.
                    checkoutCmd!=#git!.checkout().setName(branchName$).setUpstreamMode(SetupUpstreamMode.TRACK).setStartPoint("remotes/origin/"+branchName$)
                    checkoutCmd!=checkoutCmd!.setCreateBranch(1)
                else
                    rem --- Already a local branch
                    checkoutCmd!=#git!.checkout().setName(branchName$)
                endif
                checkoutCmd!.call()
                results!=checkoutCmd!.getResult()
                status$=results!.getStatus().toString()
    
                rem --- Re-initialize
                #Branch$=#repository!.getBranch()
                #LocalBranch$="heads/"+branchName$
                #RemoteBranch$="remotes/origin/"+branchName$
                #ReleaseTag$="refs/tags/"+branchName$+"_Release"
            endif

            methodret status$
           
checkoutBranch_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend
        
        rem /**
        rem  * resets the head of the branch to a particular commit.  Calling reset without the type parameter 
        rem  * assumes a hard reset, which is what is used most of the time in an Addon upgrade. This clears any changes
        rem  * out of the working directory. We don't follow the industry default of "mixed".
        rem  */
        method public BBjNumber reset(RevCommit commit!)
            methodret #reset(commit!,"HARD")
        methodend 
 
        rem /**
        rem  * resets the head of the branch to a particular commit.   
        rem  * 
        rem  */       
        method public BBjNumber reset(RevCommit commit!, BBjString type!)
            declare ResetCommand.ResetType mode!
            declare Ref resultingCommit!
            
            REM Obtain the mode, validating against valid values
            type!=type!.toUpperCase().trim()
            resetHappened=0
            mode!=ResetCommand.ResetType.valueOf(type!,err=*next);resetHappened=1
            if (! resetHappened) then 
                message!="Invalid type for reset: "+$22$+type!+$22$+". Valid values are: "
                message!=message!+Arrays.asList(ResetCommand.ResetType.values()).toString()
                throw message!,17
            endif 
        
            resultingCommit!=#git!.reset().setRef(commit!.getName()).setMode(mode!).call()
            
            methodret resultingCommit!.getObjectId().equals(commit!.getId())
            
        methodend 

        rem /**
        rem  * Cherry picks Git repository commit given as a RevCommit object. 
        rem  * 
        rem  * @param RevCommit commit! -- Git repository commits
        rem  *
        rem  * @return HashMap failures! --  key: path
        rem  *                             value: failure reason
        rem  */
        method public HashMap cherryPick(RevCommit commit!)
            seterr cherryPick_error
            failures!=new HashMap()

            cherryPickCmd!=#git!.cherryPick()
            cherryPickCmd!.include(commit!)
            result!=cherryPickCmd!.call()

            rem --- Check for conflicts that are due to a bar/*.xml file, and resolve them by accepting ours 
            switch (result!.getStatus()) 
                case CherryPickStatus.OK
                    break
                case CherryPickStatus.CONFLICTING
                    status!=#git!.status().call()
                    conflictingFiles!=status!.getConflicting()
                    fileIter!=conflictingFiles!.iterator()
                    while (fileIter!.hasNext())
                        fileName!=cast(BBjString,fileIter!.next())
                        if (fileName!.matches("data/bar/.*\.xml")) then  
                            rem --- Choose ours for bar/*.xml file conflicts
                            checkoutCmd!=#git!.checkout()
                            checkoutCmd!.setStage(Stage.OURS)
                            checkoutCmd!.addPath(fileName!)
                            checkoutCmd!.call()
                            #git!.add().addFilepattern(fileName!).call()
                        endif
                    wend
                    break
                case CherryPickStatus.FAILED
                    failures!=result!.getFailingPaths()
                    break
            swend 
            
            methodret failures!
           
cherryPick_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Free resources associated with this instance. 
        rem  */
        method public void closeInterface()
            seterr closeInterface_error

            #repository!.close()
            #git!.close()
            
            methodret
           
closeInterface_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Returns the commit Object ID for a given branch or tag name. 
        rem  * 
        rem  * @param BBjString branch_tag$ -- branch or tag name
        rem  *
        rem  * @return ObjectId commitId!
        rem  */
        method public ObjectId getCommitId(BBjString branch_tag$)
            seterr getCommitID_error
            commitId!=null()

            revWalk!=new RevWalk(#repository!)
            commit!=#repository!.resolve(branch_tag$)
            if commit!<>null() then
                revObject!=revWalk!.peel(revWalk!.parseAny(commit!))
                commitId!=revObject!.getId()
            endif
            
            methodret commitId!
           
getCommitID_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Builds list of commits made from since$ through until$. 
        rem  * 
        rem  * @param BBjString since$ -- branch or tag name since
        rem  * @param BBjString until$ -- branch or tag name until
        rem  *
        rem  * @return java.util.List commits!
        rem  */
        method public java.util.List getCommits(BBjString since$, BBjString until$)
            seterr getCommits_error
            commits!=null()
            untilId!=#getCommitId(until$)
            sinceId!=#getCommitId(since$)

            if untilId!<>null() and sinceId!<>null() then
                logCmd!=#git!.log().addRange(untilId!,sinceId!)
                revCommits!=logCmd!.call()
                commits!=cast(java.util.List,java.util.stream.StreamSupport.stream(revCommits!.spliterator(),0).collect(java.util.stream.Collectors.toList()))
            endif
            
            methodret commits!
           
getCommits_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Builds Vector of file names for conflicts in local Git repository. 
        rem  *
        rem  * @return BBjVector conflicts!
        rem  */
        method public BBjVector getConflicts()
            seterr getConflicts_error
            conflicts!=BBjAPI().makeVector()

            status!=#git!.status().call()
            conflictingFiles!=status!.getConflicting()
            conflicts!.addAll(conflictingFiles!)
            
            methodret conflicts!
           
getConflicts_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 
    
        rem /**
        rem  * Builds Vector of local commits made from since$ through until$ that 
        rem  * were NOT pushed to the remote repository. 
        rem  * 
        rem  * @param BBjString since$ -- branch or tag name since
        rem  * @param BBjString until$ -- branch or tag name until
        rem  *
        rem  * @return BBjVector filteredLocalCommits!
        rem  */
        method public BBjVector getLocalCommits(BBjString since$, BBjString until$)
            seterr getLocalCommits_error
            filteredLocalCommits!=BBjAPI().makeVector()
            tmpVect!=BBjAPI().makeVector()

            remoteCommits!=#getCommits(#RemoteBranch$,until$)
            localCommits!=#getCommits(since$,until$)
            
            if remoteCommits!<>null() and localCommits!<>null()
                localCommits!.removeAll(remoteCommits!)
                commitIter!=localCommits!.iterator()
                while (commitIter!.hasNext())
                    commit!=commitIter!.next()
                    filteredLocalCommits!.addItem(commit!)
                    rem --- Once we encounter a commit that has more than one parent, we have a merge result, 
                    rem --- so grab the merge result, which has all our previous changes and stop here. 
                    if (commit!.getParentCount()>=2) then 
                        break
                    endif   
                wend
            endif
            
            rem -- Sort commits so they are from the first/earliest to the last/latest.
            if filteredLocalCommits!.size()>0 then
                for i=filteredLocalCommits!.size()-1 to 0 step -1
                    tmpVect!.addItem(filteredLocalCommits!.getItem(i))
                next i
                filteredLocalCommits!=tmpVect!
            endif
            
            methodret filteredLocalCommits!
           
getLocalCommits_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 
    
        rem /**
        rem  * Builds Tree of bar/*.xml files in a Vector of filtered local commits. 
        rem  * 
        rem  * @param BBjVector localCommits! -- filtered local commits
        rem  *
        rem  * @return TreeSet localCommittedXmls!
        rem  */
        method public TreeSet getLocalCommittedXmls(BBjVector localCommits!)
            seterr getLocalCommittedXmls_error
            localCommittedXmls!=new TreeSet()

            commitIter!=localCommits!.iterator()
            while commitIter!.hasNext()
                commit!=commitIter!.next()
                prevCommit!=commit!.getParent(commit!.getParentCount()-1)
    
                treeParser!=new CanonicalTreeParser(null(), #repository!.newObjectReader(), commit!.getTree().getId())
                prevTreeParser!=new CanonicalTreeParser(null(), #repository!.newObjectReader(), prevCommit!.getTree().getId())

                diffCmd! = #git!.diff()
                diffCmd!.setNewTree(treeParser!)
                diffCmd!.setOldTree(prevTreeParser!)
                diffs!=diffCmd!.call()

                diffIter!=diffs!.iterator()
                while diffIter!.hasNext()
                    diff!=diffIter!.next()
                    if diff!.getNewPath().matches("^data/bar/.*\.xml$") then 
                        localCommittedXmls!.add(diff!.getNewPath())
                    endif
                wend
            wend
            
            methodret localCommittedXmls!
           
getLocalCommittedXmls_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 
    
        rem /**
        rem  * Builds Tree of bar/*.xml files committed from since$ through until$ that 
        rem  * were NOT pushed to the remote repository. 
        rem  * 
        rem  * @param BBjString since$ -- branch or tag name since
        rem  * @param BBjString until$ -- branch or tag name until
        rem  *
        rem  * @return TreeSet localCommittedXmls!
        rem  */
        method public TreeSet getLocalCommittedXmls(BBjString since$, BBjString until$)
            seterr getLocalCommittedXmls2_error

            localCommits!=#getLocalCommits(since$, until$)
            localCommittedXmls!=#getLocalCommittedXmls(localCommits!)
            
            methodret localCommittedXmls!
           
getLocalCommittedXmls2_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Returns the contents of the specified file from the remote repository. 
        rem  * 
        rem  * @param BBjString filePath$ -- file name, including path within the repository
        rem  *
        rem  * @return BBjString fileContent$
        rem  */
        method public BBjString getRemoteFileContent(BBjString filePath$)
            seterr getRemoteFileContent_error

            commit!=#repository!.resolve("refs/remotes/origin/"+#Branch$+"^{tree}")
            commitArray!=Array.newInstance(commit!.getClass(),1)
            Array.set(commitArray!,0,commit!)

            rem --- Create original version of modified bar/*.xml files in list.
            treeWalk!=TreeWalk.forPath(#repository!,filePath$,commitArray!)
            if treeWalk!<>null()
                reader!=#repository!.newObjectReader()
                loader!=reader!.open(treeWalk!.getObjectId(0))
                fileContent$=new String(loader!.getBytes(),StandardCharsets.UTF_8)

                reader!.close()
                treeWalk!.close()
            endif
            methodret fileContent$
           
getRemoteFileContent_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Get Git RevCommit object from given BBjString. 
        rem  * 
        rem  * @param BBjString commit$! -- example:
        rem  *                              commit 1ce0c5f8e453278e12f10795164613693d09d218 1590167270 ----sp
        rem  *
        rem  * @return RevCommit revCommit!
        rem  */
        method public RevCommit getRevCommit(BBjString commit$)
            seterr getRevCommit_error
            revCommit!=null()
            
            rem --- Reduce commit string down to just the hex characters
            hexChars$=commit$
            if pos("commit "=hexChars$) then hexChars$=hexChars$(pos("commit "=hexChars$)+len("commit "))
            if pos(" ----sp"=hexChars$) then hexChars$=hexChars$(1,pos(" ----sp"=hexChars$)-1)
            if pos(" "=hexChars$) then hexChars$=hexChars$(1,pos(" "=hexChars$)-1)

            if ObjectId.isId(hexChars$) then
                objectId!=ObjectId.fromString(hexChars$)
                logCmd!=#git!.log().add(objectId!).setMaxCount(1)
                revCommits!=logCmd!.call()
                commits!=cast(java.util.List,java.util.stream.StreamSupport.stream(revCommits!.spliterator(),0).collect(java.util.stream.Collectors.toList()))
                
                commitsIter!=commits!.iterator()
                while commitsIter!.hasNext()
                    revCommit!=commitsIter!.next()
                wend
            endif
                        
            methodret revCommit!
           
getRevCommit_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Get Vector of uncommitted staged changes in the local repository has . 
        rem  *
        rem  * @return BBjVector stagedChanges!
        rem  */
        method public BBjVector getStagedChanges()
            seterr getStagedChanges_error
            stagedChanges!=BBjAPI().makeVector()

            diffCmd!=#git!.diff().setCached(1)
            if diffCmd!<>null() then
                diffIter!=diffCmd!.call().iterator()
                while diffIter!.hasNext()
                    diffEntry!=diffIter!.next()
                    stagedChanges!.addItem(diffEntry!.getNewPath())
                wend
            endif
            
            methodret stagedChanges!
           
getStagedChanges_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Get Vector of uncommitted unstaged changes in the local repository. 
        rem  *
        rem  * @return BBjVector unstagedChanges!
        rem  */
        method public BBjVector getUnstagedChanges()
            seterr getUnstagedChanges_error
            unstagedChanges!=BBjAPI().makeVector()

            diffCmd!=#git!.diff()
            if diffCmd!<>null() then
                diffIter!=diffCmd!.call().iterator()
                while diffIter!.hasNext()
                    diffEntry!=diffIter!.next()
                    unstagedChanges!.addItem(diffEntry!.getNewPath())
                wend
            endif
            
            methodret unstagedChanges!
           
getUnstagedChanges_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Refresh (pull) the local repository. 
        rem  */
        method public void pullRepository()
            seterr pullRepository_error

            pullCmd!=#git!.pull()
            pullCmd!.setCredentialsProvider(#credentials!)
            pullCmd!.call()
            
            methodret
           
pullRepository_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")   
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 
        
        rem /**
        rem  * Method for testing. 
        rem  */
        method public void testPrint()

            print "#Branch$=",#Branch$
            print "#LocalBranch$=",#LocalBranch$
            print "#RemoteBranch$=",#RemoteBranch$
            print "#ReleaseTag$=",#ReleaseTag$

            localCommits!=#getLocalCommits(#LocalBranch$,#ReleaseTag$)
            print "localCommits!=",localCommits!

            localCommittedXmls!=#getLocalCommittedXmls(localCommits!)
            print "localCommittedXmls!=",localCommittedXmls!
      
            methodret
        methodend
		
		REM Commits all the changes in the working directory. 
		REM automaticallyStage!:  If set to 1 or nonzero, stages all changes before checking in. Does not add files. 
		REM message!: Commit message for repository log
		method public RevCommit commitAll(BBjNumber automaticallyStage!, BBjString message!)
			methodret #git!.commit().setAll(automaticallyStage!).setMessage(message!).call()	
		methodend 
		
        REM Method and companion methods for identifying files that are only different due to line endings. 
        REM Assumptions made here are: 
        REM     There's one huge difference and it's the entire file. 
        REM     The differences are between $0A$ and $0D0A$
        REM 
        REM If files are found to only differ by different line endings, we revert the working copy. 
        method public void checkoutFilesWithDifferentLineEndings() 
            declare Repository repository!
            declare ByteArrayOutputStream outputStream!
            declare DiffFormatter formatter!
            declare FileTreeIterator workTreeIterator!
            declare java.util.List diffEntries!
            declare Iterator diffIter!
            declare DiffEntry entry!
            declare RevWalk revWalk!
            declare CheckoutCommand checkoutCmd!
            
            repository!=#git!.getRepository()
            outputStream!=new ByteArrayOutputStream()
            
            REM Get a revcommit for the head of the repository
            declare ObjectId headObjectId!
            declare RevCommit headRevCommit!
            headObjectId!=repository!.resolve(Constants.HEAD)
            revWalk!=new RevWalk(repository!)
            headRevCommit!=revWalk!.parseCommit(headObjectId!)
            
            REM Get a list of diffs between the working tree and head commit
            formatter! = new DiffFormatter(outputStream!)
            formatter!.setRepository(repository!)
            commitTreeIterator! = #prepareTreeParser(headRevCommit!)
            workTreeIterator! = new FileTreeIterator(repository!)
            diffEntries! = formatter!.scan(commitTreeIterator!, workTreeIterator!)
    
            REM Process the diffs 
            diffIter!=diffEntries!.iterator()
            
            declare BBjVector filesToCheckOut!
            filesToCheckOut!=BBjAPI().makeVector() 
            
            while (diffIter!.hasNext())  
                entry!=cast(DiffEntry,diffIter!.next())
                formatter!.format(entry!)
                x$=outputStream!.toString()
                outputStream!.reset()
            
                declare BBjString fileName!
                fileName!=entry!.getNewPath()
                diffOnlyShowsLineEndings=#diffOnlyShowsLineEndings(x$)
                if (diffOnlyShowsLineEndings) then 
                    REM Add the file to the list of files to check out. 
                    filesToCheckOut!.add(entry!.getNewPath())
                endif 
            wend 
            
            if (filesToCheckOut!.size()>0) then 
                checkOutCmd!=#git!.checkout()
                checkOutCmd!.addPaths(filesToCheckOut!)
                checkOutCmd!.call()
            endif  
                
        methodend
        
        REM Prepare Tree Parser 
        method protected CanonicalTreeParser prepareTreeParser(RevCommit commit!)
            declare RevWalk walk!
            declare Repository repository!
            declare ObjectId treeId!
            declare ObjectReader reader!
            
            repository!=#git!.getRepository()
            walk! = new RevWalk(repository!)
            treeId! = commit!.getTree().getId()
            reader! = repository!.newObjectReader()
            methodret new CanonicalTreeParser(null(), reader!, treeId!)
        methodend 
        
        REM Called by filesWithDifferentLineEndings
        method public BBjNumber diffOnlyShowsLineEndings(BBjString diff!)
        
            REM The file should just have one big difference 
            declare BBjString search!
            declare BBjString left!
            declare BBjString right!
            declare BBjNumber first!
            declare BBjNumber last!
            declare BBjNumber diffBegins!
            declare BBjNumber leftBegins!
            declare BBjNumber rightBegins!
            declare BBjNumber nextLineBegins!
            declare BBjNumber nextLineEnds!
            declare BBjString leftSide!
            declare BBjString rightSide!
            
            search!=$0A$+"@@"
            first!=diff!.indexOf(search!)
            last!=diff!.lastIndexOf(search!)
            
            if last!<>first! then methodret 0
            
            diffBegins!=last!
            leftDelimiter!=$0A$+"-"
            rightDelimiter!=$0A$+"+"
            
            leftSide!=#getSide(diff!,leftDelimiter!,diffBegins!)
            rightSide!=#getSide(diff!,rightDelimiter!,diffBegins!)
            
            methodret leftSide!=rightSide!
        methodend 
        
        REM Called by diffOnlyShowsLineEndings
        method protected BBjString getSide(BBjString diff!, BBjString delimiter!, BBjNumber diffBegins!)
            declare BBjNumber begins!
            declare BBjNumber nextLineBegins!
            declare BBjString side!
            
            begins!=diff!.indexOf(delimiter!,diffBegins!)
            nextLineBegins!=begins!
            
            side!=""
            while (nextLineBegins!>0)
                nextLineEnds!=diff!.indexOf($0A$,nextLineBegins!+1)
                if (nextLineEnds!<0) then 
                    nextLineEnds!=diff!.length()
                endif 
                if (diff!.substring(nextLineEnds!-1,nextLineEnds!)=$0D$) then 
                    nextLineEnds!=nextLineEnds!-1
                endif 
                
                side!=side!+diff!.substring(nextLineBegins!+2,nextLineEnds!)
                
                nextLineBegins!=diff!.indexOf(delimiter!,nextLineBegins!+1)
           wend 
           methodret side!
        methodend 
               
        REM Method to look at a non-Git Addon install and figure out to what version it is closest. 
        method public BBjNumber determineAndSwitchToVersion(BBjString ungitifiedAonDirName$)
            declare BBjString fixedIssuesFileName$
            declare BBjString version!
            declare java.util.Date date!
            declare java.util.List tagList!
            declare Iterator tagIter!
            declare Ref currentTag!
            declare BBjVector relevantTags!
            declare BBjString tagSearchString!
            declare RevCommit currentCommit!
            declare RevWalk walk!
            

            REM If we have FixedIssues.txt, use it to determine what version of Addon we should be using
            fixedIssuesFileName$=ungitifiedAonDirName$+"/documentation/FixedIssues.txt"
            
            #fixedIssuesReader!=new FixedIssuesReader() 
            if (#fixedIssuesReader!.parse(fixedIssuesFileName$)) then 
                version!=#fixedIssuesReader!.getVersion()
                fixedIssuesDate!=#fixedIssuesReader!.getDate()
            else 
                throw "Could not find FixedIssues.txt file at "+fixedIssuesFileName$,12
            endif 
            
            REM At this point, we need to check out the branch to create the "heads/<branch name> ref."
            branchName$="BBJ"+version!+"GA"
            branchString!="heads/"+branchName$
            #checkoutBranch(branchName$)
            
            REM Find the commit closest to the date
            tagList!=#git!.tagList().call()
            
            REM Get the tags that start with our release. Unfortunately, the stream() interface does 
            REM not translate to BBj. 
            tagIter!=tagList!.iterator()
            tagSearchString!="refs/tags/"+branchName$+"_"
            relevantTags!=BBjAPI().makeVector()
            
            REM Put the top of the branch on relevant tags list 
            topOfBranch!=#git!.getRepository().findRef(branchString!)
            relevantTags!.add(topOfBranch!)
            
            REM Gather the relevant tags and put them in the relevant tags list
            chosenTag!=null()
            chosenTimeDifference!=Integer.MAX_VALUE
            while (tagIter!.hasNext()) 
                currentTag!=cast(Ref,tagIter!.next())
                
                if (currentTag!.getName().startsWith(tagSearchString!)) then
                    relevantTags!.add(currentTag!)
                endif 
            wend 
           
            REM Find the tag with the closest date to the release 
            tagIter!=relevantTags!.iterator() 
            walk!=new RevWalk(#git!.getRepository())
            while (tagIter!.hasNext())
                currentTag!=cast(Ref,tagIter!.next())
                currentCommit!=walk!.parseCommit(currentTag!.getObjectId())
                    
                currentCommitTime!=currentCommit!.getCommitTime()
                fixedIssuesTime!=fixedIssuesDate!.getTime()/1000
                timeDifference!=currentCommitTime!-fixedIssuesTime!
                    
                if (timeDifference!>-1) and (timeDifference!<chosenTimeDifference!) then 
                      chosenTag!=currentCommit!
                      chosenTimeDifference!=timeDifference!
                endif  
            wend 
            
            REM If we found a closely matching tag, return it. Otherwise, return null. 
            if (chosenTag!<>null()) then 
                methodret #reset(chosenTag!)
            else 
                methodret 0
            endif 
            
        methodend 

classend

REM Parses the FixedIssues file and extracts the version and date from the file if successful
class public AO_FixedIssuesReader 
    field public BBjString Version!=null()
    field public java.util.Date Date!=null()
    
    REM Constants 
    field protected BBjString DATE_TOKEN!="Report Date:"
    field protected BBjString VERSION_TOKEN!="Report Branch: AddonSoftware "
    field protected BBjString DATE_FORMAT_STRING!="yyyy-MM-dd"
    
    method public BBjNumber parse(BBjString fixedIssuesFileName$)
        declare BBjNumber chan
        declare BBjNumber dateLineFound
        declare BBjNumber versionLineFound 
        declare BBjNumber eof
        declare BBjString line$
        declare BBjString line!
        
        chan=unt
        open (chan) fixedIssuesFileName$
            
        dateLineFound=0
        versionLineFound=0
        while (!dateLineFound or !versionLineFound) 
            read (chan,end=eof) line$
            line!=line$
            
            REM if the line has a date, assign it to dateLine
            if (line!.contains(#DATE_TOKEN!) and !dateLineFound) then 
                dateLineFound=1
                dateLine!=line!
            endif 
            
            REM if the line has a version assign it to versionLine
            if (line!.contains(#VERSION_TOKEN!) and !versionLineFound) then 
                versionLineFound=1
                versionLine!=line!
            endif 
            
            continue 
        eof:
            REM --- when we've reached the end of the file, stop looping
            break
        wend 
        close (chan)
        
        REM If we did not find our version and date, then return false here. 
        if (!dateLineFound or !versionLineFound) then
            methodret 0
        endif 
        
        REM Extract the date from the date line we read in
        dateLine!=dateLine!.substring(dateLine!.indexOf(#DATE_TOKEN!)+#DATE_TOKEN!.length())
        dateFormat!=new SimpleDateFormat(#DATE_FORMAT_STRING!)
        #Date!=cast(java.util.Date,dateFormat!.parse(dateLine!))
        
        REM Extract version from the version line we read in
        versionLine!=versionLine!.substring(versionLine!.indexOf(#VERSION_TOKEN!)+#VERSION_TOKEN!.length())
        version!=versionLine!.trim()
        periodNdx=version!.indexOf(".")
        #Version!=version!.substring(0,periodNdx)+version!.substring(periodNdx+1)
        
        methodret 1 
        
    methodend 
    
classend 
