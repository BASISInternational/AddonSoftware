rem ==========================================================================
rem --- ado_AO_GitRepoInterface.aon
rem --- AO_GitRepoInterface class (GitRepoInterface superclass)
rem --- Superclass used to interface with JGit.
rem ---
rem --- Copyright BASIS International Ltd.  All Rights Reserved.
rem ==========================================================================

rem /**
rem  * This class uses JGit to interface with Addon's Git repository to perform
rem  * tasks needed during upgrades and updates.
rem  */

    use ::ado_GitRepoInterface.aon::FixedIssuesReader
    use ::sys/prog/bao_encryptor.bbj::Encryptor

    use java.io.ByteArrayOutputStream
    use java.io.File
    use java.io.FileReader
    use java.io.BufferedReader    
    use java.lang.Boolean
    use java.lang.reflect.Array
    use java.nio.charset.StandardCharsets
    use java.nio.file.Files
    use java.nio.file.FileSystems
    use java.nio.file.FileVisitResult
    use java.nio.file.Path
    use java.nio.file.Paths
    use java.nio.file.SimpleFileVisitor
    use java.nio.file.attribute.BasicFileAttributes
    use java.nio.file.attribute.PosixFilePermissions
    use java.nio.file.attribute.UserPrincipal
    use java.nio.file.attribute.UserPrincipalLookupService
    use java.util.regex.Matcher
    use java.util.regex.Pattern
    use java.text.SimpleDateFormat
    use java.util.Date
    use java.util.HashMap
    use java.util.Map
    use java.util.TreeSet
    use java.util.ArrayList
    use java.util.Arrays
    use java.util.Iterator
    use java.util.stream.Collectors
    use java.util.TreeMap
    use java.util.Vector

    use com.jcraft.jsch.JSch
    use com.jcraft.jsch.Session

    use org.eclipse.jgit.api.CheckoutCommand
    use org.eclipse.jgit.api.CheckoutCommand.Stage
    use org.eclipse.jgit.api.CherryPickResult.CherryPickStatus
    use org.eclipse.jgit.api.FetchCommand
    use org.eclipse.jgit.api.LsRemoteCommand
    use org.eclipse.jgit.api.TransportConfigCallback
    use org.eclipse.jgit.api.ResetCommand
    use org.eclipse.jgit.api.ResetCommand.ResetType
    use org.eclipse.jgit.api.CreateBranchCommand.SetupUpstreamMode
    use org.eclipse.jgit.api.Git
    use org.eclipse.jgit.diff.DiffEntry
    use org.eclipse.jgit.diff.DiffFormatter
    use org.eclipse.jgit.lib.AnyObjectId
    use org.eclipse.jgit.lib.Constants
    use org.eclipse.jgit.lib.ObjectId
    use org.eclipse.jgit.lib.ObjectReader
    use org.eclipse.jgit.lib.Repository
    use org.eclipse.jgit.lib.Ref
    use org.eclipse.jgit.merge.Merger
    use org.eclipse.jgit.merge.MergeResult
    use org.eclipse.jgit.merge.MergeStrategy
    use org.eclipse.jgit.merge.ThreeWayMerger
    use org.eclipse.jgit.merge.ResolveMerger
    use org.eclipse.jgit.merge.RecursiveMerger
    use org.eclipse.jgit.revwalk.RevCommit
    use org.eclipse.jgit.revwalk.RevWalk
    use org.eclipse.jgit.transport.CredentialsProvider
    use org.eclipse.jgit.transport.FetchResult
    use org.eclipse.jgit.transport.JschConfigSessionFactory
    use org.eclipse.jgit.transport.OpenSshConfig
    use org.eclipse.jgit.transport.RefSpec
    use org.eclipse.jgit.transport.SshTransport
    use org.eclipse.jgit.transport.Transport
    use org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider
    use org.eclipse.jgit.treewalk.CanonicalTreeParser
    use org.eclipse.jgit.treewalk.FileTreeIterator
    use org.eclipse.jgit.treewalk.TreeWalk
    use org.eclipse.jgit.util.FS
    use org.eclipse.jgit.util.SystemReader

rem /**
rem  * This class uses JGit to interface with Addon's Git repository to perform
rem  * tasks needed during upgrades and updates.
rem  */

    class public AO_GitRepoInterface
        field public BBjString AonDir$
        field public BBjString Branch$
        field public BBjString LocalBranch$
        field public BBjString LocalRepo$
        field public BBjString ReleaseTag$
        field public BBjString RemoteBranch$
        field public BBjString RepoURL!
        field public BBjString GitAuthID$

        field protected Git git!
        field protected Repository repository!
        field protected BBjString encryptionConfiguration!="PASSWORD_USER"
        field protected CredentialsProvider credentials!
        field protected TransportConfigCallback transportConfigCallback!

        REM Fields for verification
        field protected BBjString verificationBranch!="refs/heads/mod1500bt"
        field protected BBjString verificationObjectId!="AnyObjectId[d6ccfe9fe78bfe9fad7496f0cefcae154dcc3092]"

        field protected FixedIssuesReader fixedIssuesReader!

        field public BBjString ReorderedTagName!
        field public BBjString FullReorderedTagName!

        rem /**
        rem  * Constructor.
        rem  * Instantiates authentication in order to query a remote Addon archive
        rem  *
        rem  * @param BBjString gitAuthID$
        rem  */
        method public AO_GitRepoInterface(BBjString gitAuthID$)
            #GitAuthID$=gitAuthID$
            #obtainURLAndCredentials(gitAuthID$)
        methodend

        rem /**
        rem  * Constructor.
        rem  * Instantiates authentication in order to query a remote Addon
        rem  * archive that is not necessarily in the ADX_GIT_AUTH table.
        rem  *
        rem  * @param BBjString gitAuthID$
        rem  * @param BBjString url$
        rem  * @param BBjString username$
        rem  * @param BBjString password$
        rem  * @param BBjString sshKeyFile$
        rem  * @param BBjString sshPassword$
        rem  * @param BBjString authToken$
        rem  */
        method public AO_GitRepoInterface(BBjString gitAuthID$, BBjString url$, BBjString username$, BBjString password$, BBjString sshKeyFile$, BBjString sshPassword$, BBjString authToken$)
            #GitAuthID$=gitAuthID$
            #obtainURLAndCredentials(gitAuthID$,url$,username$,password$,sshKeyFile$,sshPassword$,authToken$)
        methodend

        rem /**
        rem  * Constructor.
        rem  * Clones Git repository to specified location if one does not already exist there.
        rem  *
        rem  * @param BBjString gitAuthID$
        rem  * @param BBjString aonDir$
        rem  */
        method public AO_GitRepoInterface(BBjString gitAuthID$, BBjString aonDir$)

            #this!(gitAuthID$)

            seterr GitRepoInterface_error
            #AonDir$=aonDir$
            #LocalRepo$=#AonDir$+"/.git"

            rem --- Before cloning, set the autocrlf property. in user's home/.gitconfig to FALSE
            userCfg!=SystemReader.getInstance().getUserConfig()
            userCfg!.setBoolean("core", null(), "autocrlf", Boolean.FALSE)
            userCfg!.save()

            rem --- Get Git repository
            gitDir! = new File(#LocalRepo$)
            if !gitDir!.exists() then
                rem --- Clone Git repository to specified location
                cloneCmd!=Git.cloneRepository()

                rem -- build the clone command
                cloneCmd!=cloneCmd!.setURI(#RepoURL!)
                if (#credentials!<>null()) then
                    cloneCmd!=cloneCmd!.setCredentialsProvider(#credentials!)
                else
                    if (#transportConfigCallback!<>null()) then
                        cloneCmd!=cloneCmd!.setTransportConfigCallback(#transportConfigCallback!)
                    endif
                endif
                cloneCmd!=cloneCmd!.setDirectory(new File(aonDir$))
                cloneCmd!=cloneCmd!.setCloneAllBranches(1)
                cloneCmd!.call()

                declare OwnerSetter setter!
                setter!=new OwnerSetter()
                if (! setter!.getOSIsWindows()) then
                    setter!.setOwnerRecursively(aonDir$)
                endif
            endif
            #git!=Git.open(new File(#LocalRepo$))

            rem --- Initializations
            #repository!=#git!.getRepository()
            #Branch$=#repository!.getBranch()
            branchName$=#Branch$(1+pos("/"=#Branch$))
            #LocalBranch$="heads/"+branchName$
            #RemoteBranch$="remotes/origin/"+branchName$
            #ReleaseTag$="refs/tags/"+branchName$+"_Release"
            #ReorderedTagName!=branchName$+"_Reordered"
            #FullReorderedTagName!="refs/tags/"+#ReorderedTagName!

            methodret

GitRepoInterface_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  *
        rem  */
        method public void obtainURLAndCredentials(BBjString gitAuthID$)
            declare BBjNumber sqlchan
            declare BBjString template$
            declare BBjString result$
            declare BBjString userName$
            declare BBjString password$
            declare BBjString token$
            declare BBjString sshKeyFile$
            declare BBjString sshKeyPassword$

            REM read the record from the ADX_GIT_AUTH table
            sqlchan=sqlunt
            sqlopen(sqlchan) STBL("+DBNAME")
            sqlprep(sqlchan) "select * from ADX_GIT_AUTH where GIT_AUTH_ID=?"
            sqlexec(sqlchan) gitAuthID$
            template$=sqltmpl(sqlchan)
            dim result$:template$

            result$=sqlfetch(sqlchan)
            sqlclose(sqlchan)

            #obtainURLAndCredentials(result.GIT_AUTH_ID$, result.URL$, result.USERNAME$, result.PASSWORD$, result.SSH_KEY_FILE$, result.SSH_PASSWORD$, result.TOKEN$)

        methodend

        method public void obtainURLAndCredentials(BBjString gitAuthID$, BBjString url$, BBjString username$, BBjString password$, BBjString sshKeyFile$, BBjString sshKeyPassword$, BBjString authToken$)
            declare Encryptor encryptor!

            REM Read in our Encryptor configuration and create our decryptor.
            encryptor!=new Encryptor()
            encryptor!.setConfiguration(#encryptionConfiguration!)

            #RepoURL!=cvs(url$,3)

            password$=encryptor!.decryptData(cvs(password$,3))
            token$=encryptor!.decryptData(cvs(authToken$,3))
            sshKeyFile$=cvs(sshKeyFile$,3)
            sshKeyPassword$=encryptor!.decryptData(cvs(sshKeyPassword$,3))

            REM Check to see if this is a public repo and if so, return null
            isPublic=(userName$="") and (password$="") and (token$="") and (sshKeyFile$="")
            if (isPublic) then
                #credentials!=null()
                methodret
            endif

            REM determine the type of credentials in the table: none, user/password, OAuth token, public key
            REM username/password
            if (userName$<>"") then
                declare UsernamePasswordCredentialsProvider upProvider!
                upProvider!=new UsernamePasswordCredentialsProvider(userName$,password$)
                #credentials!=upProvider!
                methodret
            endif

            if (token$<>"") then
                declare UsernamePasswordCredentialsProvider tokenProvider!
                tokenProvider!=new UsernamePasswordCredentialsProvider(token$,"")
                #credentials!=tokenProvider!
                methodret
            endif

            if (sshKeyFile$<>"") then
                if (sshKeyPassword$<>"") then
                    #transportConfigCallback!=new SSH(sshKeyFile$,sshKeyPassword$)
                else
                    #transportConfigCallback!=new SSH(sshKeyFile$)
                endif
                methodret
            endif
        methodend

        rem /**
        rem  *  isDescedantOfOfficialRepo()
        rem  */
        method public BBjNumber isDescendantOfOfficialRepo() 
            declare LsRemoteCommand lsRemoteCmd!
            declare java.util.Collection lsResult!
            declare Iterator resultIterator!
            declare Ref currentResult!

            lsRemoteCmd!=Git.lsRemoteRepository()
            lsRemoteCmd!=lsRemoteCmd!.setRemote(#RepoURL!)

            if (#credentials!<>null()) then
                lsRemoteCmd!=cast(LsRemoteCommand,lsRemoteCmd!.setCredentialsProvider(#credentials!))
            else
                if (#transportConfigCallback!<>null()) then
                    lsRemoteCmd!=cast(LsRemoteCommand,lsRemoteCmd!.setTransportConfigCallback(#transportConfigCallback!))
                endif
            endif
            lsResult!=lsRemoteCmd!.call()

            REM see if this repo has the verification branch and if the commit id for that branch matches
            resultIterator!=lsResult!.iterator()
            while (resultIterator!.hasNext())
                currentResult!=cast(Ref,resultIterator!.next())
                print currentResult!.getName(), #verificationBranch!
                if (currentResult!.getName()=#verificationBranch!) then break
            wend

            REM return whether we got a match and if the commit id is correct.
            methodret (currentResult!.getName()=#verificationBranch!) and (currentResult!.getObjectId().toString()=#verificationObjectId!)
        methodend

        rem /**
        rem  *  Look for tag for this release branch
        rem  *  Only official/tagged releases can be used, i.e., not RCs
        rem  *  @param BBjString version
        rem  */
        method public BBjNumber isTaggedRelease(BBjString version_id$) 
            declare LsRemoteCommand lsRemoteCmd!
            declare java.util.Collection lsResult!
            declare Iterator resultIterator!
            declare Ref currentResult!
            
            versionTag$="refs/tags/BBJ"+version_id$+"GA_Release"

            lsRemoteCmd!=Git.lsRemoteRepository()
            lsRemoteCmd!=lsRemoteCmd!.setRemote(#RepoURL!)
            lsRemoteCmd!.setTags(true)
            lsResult!=lsRemoteCmd!.call()

            REM see if a tag exists for the version we're installing/upgrading to
            resultIterator!=lsResult!.iterator()
            while (resultIterator!.hasNext())
                currentResult!=cast(Ref,resultIterator!.next())
                if (currentResult!.getName().equals(versionTag$)) then break
            wend

            methodret currentResult!.getName().equals(versionTag$)
        methodend

        rem /**
        rem  * Checkout (i.e. switch to) specified branch in repository.
        rem  *
        rem  * @param BBjString branchName$ -- branch name
        rem  *
        rem  * @return BBjString status$ -- OK - Checkout completely normal
        rem  *                              ERROR - An Exception occurred during checkout
        rem  *                              CONFLICTS - Checkout has not completed because of checkout conflicts
        rem  *                              NONDELETED - Checkout has completed, but some files could not be deleted
        rem  *                              NOT_TRIED - The call() method has not yet been executed
        rem  */
        method public BBjString checkoutBranch(BBjString branchName$)
            seterr checkoutBranch_error
            status$="OK"

            rem --- Is this already the current branch?
            if branchName$<>#repository!.getBranch() then
                if #repository!.resolve("heads/"+branchName$)=null() then
                    rem --- Not currently a local branch, so create it.
                    checkoutCmd!=#git!.checkout().setName(branchName$).setUpstreamMode(SetupUpstreamMode.TRACK).setStartPoint("remotes/origin/"+branchName$)
                    checkoutCmd!=checkoutCmd!.setCreateBranch(1)
                else
                    rem --- Already a local branch
                    checkoutCmd!=#git!.checkout().setName(branchName$)
                endif
                checkoutCmd!.call(err=*next)
                results!=checkoutCmd!.getResult()
                status$=results!.getStatus().toString()
                if status$="OK"
                    declare OwnerSetter setter!
                    setter!=new OwnerSetter()
                    if (! setter!.getOSIsWindows()) then
                        setter!.setOwnerRecursively(#AonDir$)
                    endif

                    rem --- Re-initialize
                    #Branch$=#repository!.getBranch()
                    #LocalBranch$="heads/"+branchName$
                    #RemoteBranch$="remotes/origin/"+branchName$
                    #ReleaseTag$="refs/tags/"+branchName$+"_Release"
                else
                    status$=status$+": "+BBjAPI().getLastBBjException().getMessage().toString()
                endif
            endif

            methodret status$

checkoutBranch_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem  /**
        rem  * set permissions recursively on directories/files under aon directory (non-Windows OS)
        rem  * @param BBjString aonDir$ -- aon directory path
        rem  */
        method public void setPermsRecursive(BBjString aonDir$)
            seterr setPermsRecursive_error
            dirPerms!=PosixFilePermissions.fromString("rwxrwxrwx")
            filePerms!=PosixFilePermissions.fromString("rw-rw-rw-")
            userPrincipal!=FileSystems.getDefault().getUserPrincipalLookupService().lookupPrincipalByName(java.lang.System.getProperty("user.name"))
            path! = Paths.get(aonDir$)
            stream! = Files.walk(path!)
            pathList! = stream!.collect(Collectors.toList())
            
            dirVector! = new Vector(pathList!)
            dirIter! = dirVector!.iterator()
            while dirIter!.hasNext()
                path! = dirIter!.next()
                file! = path!.toFile()
                if(file!.isDirectory()) then
                    Files.setPosixFilePermissions(path!,dirPerms!)
                else
                    Files.setPosixFilePermissions(path!,filePerms!)
                endif
                Files.setOwner(path!,userPrincipal!)
            wend

            methodret

setPermsRecursive_error:rem --- Method error trap/handler
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * resets the head of the branch to a particular commit.  Calling reset without the type parameter
        rem  * assumes a hard reset, which is what is used most of the time in an Addon upgrade. This clears any changes
        rem  * out of the working directory. We don't follow the industry default of "mixed".
        rem  */
        method public BBjNumber reset(RevCommit commit!)
            methodret #reset(commit!,"HARD")
        methodend

        rem /**
        rem  * resets the head of the branch to a particular commit.
        rem  *
        rem  */
        method public BBjNumber reset(RevCommit commit!, BBjString type!)
            declare ResetCommand.ResetType mode!
            declare Ref resultingCommit!

            REM Obtain the mode, validating against valid values
            type!=type!.toUpperCase().trim()
            resetHappened=0
            mode!=ResetCommand.ResetType.valueOf(type!,err=*next);resetHappened=1
            if (! resetHappened) then
                message!="Invalid type for reset: "+$22$+type!+$22$+". Valid values are: "
                message!=message!+Arrays.asList(ResetCommand.ResetType.values()).toString()
                throw message!,17
            endif

            resultingCommit!=#git!.reset().setRef(commit!.getName()).setMode(mode!).call()

            declare OwnerSetter setter!
            setter!=new OwnerSetter()
            if (! setter!.getOSIsWindows()) then
                setter!.setOwnerRecursively(#AonDir$)
            endif

            methodret resultingCommit!.getObjectId().equals(commit!.getId())

        methodend

        rem /**
        rem  * Cherry picks Git repository commit given as a RevCommit object.
        rem  *
        rem  * @param RevCommit commit! -- Git repository commits
        rem  *
        rem  * @return HashMap failures! --  key: path
        rem  *                             value: failure reason
        rem  */
        method public HashMap cherryPick(RevCommit commit!)
            seterr cherryPick_error
            failures!=new HashMap()

            cherryPickCmd!=#git!.cherryPick()
            cherryPickCmd!.include(commit!)
            result!=cherryPickCmd!.call()

            rem --- Check for conflicts that we might be able to resolve
            switch (result!.getStatus())
                case CherryPickStatus.OK
                    break
                case CherryPickStatus.CONFLICTING
                    status!=#git!.status().call()
                    conflictingFiles!=status!.getConflicting()
                    fileIter!=conflictingFiles!.iterator()
                    while (fileIter!.hasNext())
                        REM --- Accept BAR XMLs as "OURS".  Handle these later on in the upgrade
                        fileName!=cast(BBjString,fileIter!.next())
                        if (fileName!.matches("data/bar/.*\.xml")) then
                            #resolveByChoosingSide(fileName!,"OURS")
                            continue
                        endif
                        REM --- Accept adm_modules~*.xml as "OURS". We don't need THEIRS any longer.
                        rem if (fileName!.matches("data/sync/adm_modules~.*\.xml")) then
                        rem     #resolveByChoosingSide(fileName!,"OURS")
                        rem     continue
                        rem endif
                        rem --- Note: At least in the meantime, don't automatically accept addon.syn since it's
                        rem --- it's possible for the user to change a STBL that we change as well.
                        REM --- Accept addon.syn as ours.  User's changes should already be in new addon.syn
                        rem if (fileName!.matches("config/addon.syn")) then
                        rem     #resolveByChoosingSide(fileName!,"OURS")
                        rem     continue
                        rem endif
                    wend
                    break
                case CherryPickStatus.FAILED
                    failures!=result!.getFailingPaths()
                    break
            swend

            methodret failures!

cherryPick_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Cherry picks Git repository commit given as a RevCommit object.
        rem  *
        rem  * @param RevCommit commit! -- Git repository commits
        rem  *
        rem  * @return HashMap failures! --  key: path
        rem  *                             value: failure reason
        rem  */
        method public FetchResult fetch()
        methodend 
                
        method public FetchResult fetch(BBjNumber dryRun)
            methodret #git!.fetch().setDryRun(dryRun).setCredentialsProvider(#credentials!).call()
        methodend 
        
        
        rem /**
        rem  * This method performs a dry-run merge. 
        rem  * Performs a test merge in memory without modifying any files in the work area and returns the results 
        rem  * of the merge.  This method can be used to test what would happen in the event of an actual merge. If 
        rem  * the merge would fail or result in conflicts, we can know about that result before we perform the actual 
        rem  * operation. 
        rem  **/
        method public AO_MergeStatus testMerge(BBjString head1Name!, BBjString head2Name!)
            
            seterr handle_error
            
            declare AnyObjectId head1!
            declare AnyObjectId head2!
            declare Repository repository!
            declare RecursiveMerger merger!
            declare BBjNumber inMemory!
            
            repository!=#git!.getRepository()
            
            head1!=repository!.resolve(head1Name!)
            head2!=repository!.resolve(head2Name!)
            
            inMemory!=1
            merger!=cast(RecursiveMerger,MergeStrategy.RECURSIVE.newMerger(repository!,inMemory!))
            
            merger!.merge(head1!,head2!)
            
            methodret new AO_MergeStatus(merger!)
            
            handle_error: rem --- Method error trap/handler (11Oct2017)
            rem --- SDH: It might be possible to wrap this body into a method that we just call after the label.
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 


        rem /**
        rem  * If the repository is in a conflicted state, resolves a particular conflicted
        rem  * file by choosing the specified side.  The names for the sides are "THEIRS" and "OURS".
        rem  * @param path$ The file path, relative the root of the repository to reolve the
        rem  * conflict in.
        rem  * @param side$ The name of the side to choose. Valid values are "THEIRS" and "OURS".
        rem  */
        method public void resolveByChoosingSide(BBjString path!, BBjString side$)
            declare CheckoutCommand checkoutCmd!
            declare Stage stage!

            rem --- "stage!" is the enumerative constant for which side we want to choose
            stage!=Stage.valueOf(side$)

            rem ---  To resolve a single file conflict in Git,
            rem ---  checkout the file from the side we're interested in
            checkoutCmd!=#git!.checkout()
            checkoutCmd!.setStage(stage!)
            checkoutCmd!.addPath(path!)
            checkoutCmd!.call()

            declare OwnerSetter setter!
            setter!=new OwnerSetter()
            if (! setter!.getOSIsWindows()) then
                setter!.setOwnerRecursively(#AonDir$)
            endif

            rem ---  then add the file in preparation for it to be committed
            #git!.add().addFilepattern(path!).call()
        methodend

        rem /**
        rem  * Free resources associated with this instance.
        rem  */
        method public void closeInterface()
            seterr closeInterface_error

            #repository!.close()
            #git!.close()

            methodret

closeInterface_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Returns the commit Object ID for a given branch or tag name.
        rem  *
        rem  * @param BBjString branch_tag$ -- branch or tag name
        rem  *
        rem  * @return ObjectId commitId!
        rem  */
        method public ObjectId getCommitId(BBjString branch_tag$)
            seterr getCommitID_error
            commitId!=null()

            revWalk!=new RevWalk(#repository!)
            commit!=#repository!.resolve(branch_tag$)
            if commit!<>null() then
                revObject!=revWalk!.peel(revWalk!.parseAny(commit!))
                commitId!=revObject!.getId()
            endif

            methodret commitId!

getCommitID_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Builds list of commits made from since$ through until$.
        rem  *
        rem  * @param BBjString since$ -- branch or tag name since
        rem  * @param BBjString until$ -- branch or tag name until
        rem  *
        rem  * @return java.util.List commits!
        rem  */
        method public java.util.List getCommits(BBjString since$, BBjString until$)
            seterr getCommits_error
            commits!=null()
            untilId!=#getCommitId(until$)
            sinceId!=#getCommitId(since$)

            if untilId!<>null() and sinceId!<>null() then
                logCmd!=#git!.log().addRange(untilId!,sinceId!)
                revCommits!=logCmd!.call()
                commits!=cast(java.util.List,java.util.stream.StreamSupport.stream(revCommits!.spliterator(),0).collect(java.util.stream.Collectors.toList()))
            endif

            methodret commits!

getCommits_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Builds Vector of file names for conflicts in local Git repository.
        rem  *
        rem  * @return BBjVector conflicts!
        rem  */
        method public BBjVector getConflicts()
            seterr getConflicts_error
            conflicts!=BBjAPI().makeVector()

            status!=#git!.status().call()
            conflictingFiles!=status!.getConflicting()
            conflicts!.addAll(conflictingFiles!)

            methodret conflicts!

getConflicts_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend
        
        rem /**
        rem  * Builds Vector of file names for files containing embedded conflicts that have been 
        rem  * marked as resolved.
        rem  * If any are found, these have to be fixed by hand and committed or the repo needs to 
        rem  * be rolled back. 
        rem  * @return BBjVector conflicts!
        rem  */
        method public BBjVector getCommittedConflicts()
            declare BBjVector matches!
            seterr getCommittedConflicts_error
            
            matches!=Grepper.grepRecursively(#AonDir$,"<{4}|>{4}")
        
            methodret matches!
        
        getCommittedConflicts_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend 

        rem /**
        rem  * Builds Vector of local commits made from since$ through until$ that
        rem  * were NOT pushed to the remote repository.
        rem  *
        rem  * @param BBjString since$ -- branch or tag name since
        rem  * @param BBjString until$ -- branch or tag name until
        rem  *
        rem  * @return BBjVector filteredLocalCommits!
        rem  */
        method public BBjVector getLocalCommits(BBjString since$, BBjString until$)
            seterr getLocalCommits_error
            filteredLocalCommits!=BBjAPI().makeVector()
            tmpVect!=BBjAPI().makeVector()

            remoteCommits!=#getCommits(#RemoteBranch$,until$)
            localCommits!=#getCommits(since$,until$)

            if remoteCommits!<>null() and localCommits!<>null()
                localCommits!.removeAll(remoteCommits!)

                commitIter!=localCommits!.iterator()
                while (commitIter!.hasNext())
                    commit!=commitIter!.next()
                    filteredLocalCommits!.addItem(commit!)
                    rem --- Once we encounter a commit that has more than one parent, we have a merge result,
                    rem --- so grab the merge result, which has all our previous changes and stop here.
                    if (commit!.getParentCount()>=2) then
                        break
                    endif
                wend
            endif

            rem -- Sort commits so they are from the first/earliest to the last/latest.
            if filteredLocalCommits!.size()>0 then
                for i=filteredLocalCommits!.size()-1 to 0 step -1
                    tmpVect!.addItem(filteredLocalCommits!.getItem(i))
                next i
                filteredLocalCommits!=tmpVect!
            endif

            methodret filteredLocalCommits!

getLocalCommits_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Builds Tree of bar/*.xml files in a Vector of filtered local commits.
        rem  *
        rem  * @param BBjVector localCommits! -- filtered local commits
        rem  *
        rem  * @return TreeSet localCommittedXmls!
        rem  */
        method public TreeSet getLocalCommittedXmls(BBjVector localCommits!)
            seterr getLocalCommittedXmls_error
            localCommittedXmls!=new TreeSet()

            commitIter!=localCommits!.iterator()
            while commitIter!.hasNext()
                commit!=commitIter!.next()
                prevCommit!=commit!.getParent(commit!.getParentCount()-1)

                treeParser!=new CanonicalTreeParser(null(), #repository!.newObjectReader(), commit!.getTree().getId())
                prevTreeParser!=new CanonicalTreeParser(null(), #repository!.newObjectReader(), prevCommit!.getTree().getId())

                diffCmd! = #git!.diff()
                diffCmd!.setNewTree(treeParser!)
                diffCmd!.setOldTree(prevTreeParser!)
                diffs!=diffCmd!.call()

                diffIter!=diffs!.iterator()
                while diffIter!.hasNext()
                    diff!=diffIter!.next()
                    if diff!.getNewPath().matches("^data/bar/.*\.xml$") then
                        localCommittedXmls!.add(diff!.getNewPath())
                    endif
                wend
            wend

            methodret localCommittedXmls!

getLocalCommittedXmls_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Builds Tree of bar/*.xml files committed from since$ through until$ that
        rem  * were NOT pushed to the remote repository.
        rem  *
        rem  * @param BBjString since$ -- branch or tag name since
        rem  * @param BBjString until$ -- branch or tag name until
        rem  *
        rem  * @return TreeSet localCommittedXmls!
        rem  */
        method public TreeSet getLocalCommittedXmls(BBjString since$, BBjString until$)
            seterr getLocalCommittedXmls2_error

            localCommits!=#getLocalCommits(since$, until$)
            localCommittedXmls!=#getLocalCommittedXmls(localCommits!)

            methodret localCommittedXmls!

getLocalCommittedXmls2_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Returns the contents of the specified file from the remote repository.
        rem  *
        rem  * @param BBjString filePath$ -- file name, including path within the repository
        rem  *
        rem  * @return BBjString fileContent$
        rem  */
        method public BBjString getRemoteFileContent(BBjString filePath$)
            seterr getRemoteFileContent_error

            commit!=#repository!.resolve("refs/remotes/origin/"+#Branch$+"^{tree}")
            commitArray!=Array.newInstance(commit!.getClass(),1)
            Array.set(commitArray!,0,commit!)

            rem --- Create original version of modified bar/*.xml files in list.
            treeWalk!=TreeWalk.forPath(#repository!,filePath$,commitArray!)
            if treeWalk!<>null()
                reader!=#repository!.newObjectReader()
                loader!=reader!.open(treeWalk!.getObjectId(0))
                fileContent$=new String(loader!.getBytes(),StandardCharsets.UTF_8)

                reader!.close()
                treeWalk!.close()
            endif
            methodret fileContent$

getRemoteFileContent_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend


		rem /**
        rem  * Returns the contents of the specified file from specified commit.
        rem  *
        rem  * @param BBjString filePath$ -- file name, including path within the repository
		rem  * @param BBjString commitId$ -- the commit id to retreive a file from
        rem  *
        rem  * @return BBjString fileContent$
        rem  */
        method public BBjString getFileContent(BBjString filePath$, BBjString commitId$)
            seterr getRemoteFileContent_error

            commit!=#repository!.resolve(commitId$+"^{tree}")
            commitArray!=Array.newInstance(commit!.getClass(),1)
            Array.set(commitArray!,0,commit!)

            rem --- Create original version of modified bar/*.xml files in list.
            treeWalk!=TreeWalk.forPath(#repository!,filePath$,commitArray!)
            if treeWalk!<>null()
                reader!=#repository!.newObjectReader()
                loader!=reader!.open(treeWalk!.getObjectId(0))
                fileContent$=new String(loader!.getBytes(),StandardCharsets.UTF_8)

                reader!.close()
                treeWalk!.close()
            endif
            methodret fileContent$

getRemoteFileContent_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Get Git RevCommit object from given BBjString.
        rem  *
        rem  * @param BBjString commit$! -- example:
        rem  *                              commit 1ce0c5f8e453278e12f10795164613693d09d218 1590167270 ----sp
        rem  *
        rem  * @return RevCommit revCommit!
        rem  */
        method public RevCommit getRevCommit(BBjString commit$)
            seterr getRevCommit_error
            revCommit!=null()

            rem --- Reduce commit string down to just the hex characters
            hexChars$=commit$
            if pos("commit "=hexChars$) then hexChars$=hexChars$(pos("commit "=hexChars$)+len("commit "))
            if pos(" ----sp"=hexChars$) then hexChars$=hexChars$(1,pos(" ----sp"=hexChars$)-1)
            if pos(" "=hexChars$) then hexChars$=hexChars$(1,pos(" "=hexChars$)-1)

            if ObjectId.isId(hexChars$) then
                objectId!=ObjectId.fromString(hexChars$)
                logCmd!=#git!.log().add(objectId!).setMaxCount(1)
                revCommits!=logCmd!.call()
                commits!=cast(java.util.List,java.util.stream.StreamSupport.stream(revCommits!.spliterator(),0).collect(java.util.stream.Collectors.toList()))

                commitsIter!=commits!.iterator()
                while commitsIter!.hasNext()
                    revCommit!=commitsIter!.next()
                wend
            endif

            methodret revCommit!

getRevCommit_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Get Vector of uncommitted staged changes in the local repository has .
        rem  *
        rem  * @return BBjVector stagedChanges!
        rem  */
        method public BBjVector getStagedChanges()
            seterr getStagedChanges_error
            
            rem Note: You will get an error here if you used the single argument constructor, 
            rem since an Addon directory was not specified. 
            
            stagedChanges!=BBjAPI().makeVector()

            diffCmd!=#git!.diff().setCached(1)
            if diffCmd!<>null() then
                diffIter!=diffCmd!.call().iterator()
                while diffIter!.hasNext()
                    diffEntry!=diffIter!.next()
                    stagedChanges!.addItem(diffEntry!.getNewPath())
                wend
            endif

            methodret stagedChanges!

getStagedChanges_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Get Vector of uncommitted unstaged changes in the local repository.
        rem  *
        rem  * @return BBjVector unstagedChanges!
        rem  */
        method public BBjVector getUnstagedChanges()
            seterr getUnstagedChanges_error
            unstagedChanges!=BBjAPI().makeVector()

            rem Note: You will get an error here if you used the single argument constructor, 
            rem since an Addon directory was not specified. 

            diffCmd!=#git!.diff()
            if diffCmd!<>null() then
                diffIter!=diffCmd!.call().iterator()
                while diffIter!.hasNext()
                    diffEntry!=diffIter!.next()
                    unstagedChanges!.addItem(diffEntry!.getNewPath())
                wend
            endif

            methodret unstagedChanges!

getUnstagedChanges_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Refresh (pull) the local repository.
        rem  */
        method public void pullRepository()
            seterr pullRepository_error

            pullCmd!=#git!.pull()
            pullCmd!.setCredentialsProvider(#credentials!)
            pullCmd!.call()

            declare OwnerSetter setter!
            setter!=new OwnerSetter()
            if (! setter!.getOSIsWindows()) then
                setter!.setOwnerRecursively(#AonDir$)
            endif

            methodret

pullRepository_error:rem --- Method error trap/handler (11Oct2017)
            rd_err_text$="", err_num=err
            if tcb(2)=0 and tcb(5) then rd_err_text$=pgm(tcb(5),tcb(13),err=*next)
            if err_num=252 then
                E!=BBjAPI().getLastBBjException()
                rd_err_text$=rd_err_text$+$0A$+E!.getClass().getName()
                if E!.getMessage()<>null() then rd_err_text$=rd_err_text$+": "+E!.getMessage()
            endif
            call stbl("+DIR_SYP")+"bac_error.bbj",pgm(-2),str(tcb(5)),str(err_num),rd_err_text$,rd_err_act$
            if pos("ESCAPE"=rd_err_act$)<>0 seterr 0;setesc 0
            if pos("RETRY"=rd_err_act$)<>0 retry
            x$=stbl("+THROWN_ERR","TRUE")
            throw "["+pgm(-2)+"] "+str(tcb(5))+": "+rd_err_text$,err_num
        methodend

        rem /**
        rem  * Method for testing.
        rem  */
        method public void testPrint()

            print "#Branch$=",#Branch$
            print "#LocalBranch$=",#LocalBranch$
            print "#RemoteBranch$=",#RemoteBranch$
            print "#ReleaseTag$=",#ReleaseTag$

            localCommits!=#getLocalCommits(#LocalBranch$,#ReleaseTag$)
            print "localCommits!=",localCommits!

            localCommittedXmls!=#getLocalCommittedXmls(localCommits!)
            print "localCommittedXmls!=",localCommittedXmls!

            methodret
        methodend

		REM Commits all the changes in the working directory.
		REM automaticallyStage!:  If set to 1 or nonzero, stages all changes before checking in. Does not add files.
		REM message!: Commit message for repository log
		method public RevCommit commitAll(BBjNumber automaticallyStage!, BBjString message!)
			methodret #git!.commit().setAll(automaticallyStage!).setMessage(message!).call()
		methodend

        REM Method and companion methods for identifying files that are only different due to line endings.
        REM Assumptions made here are:
        REM     There's one huge difference and it's the entire file.
        REM     The differences are between $0A$ and $0D0A$
        REM
        REM If files are found to only differ by different line endings, we revert the working copy.
        method public void checkoutFilesWithDifferentLineEndings()
            declare Repository repository!
            declare ByteArrayOutputStream outputStream!
            declare DiffFormatter formatter!
            declare FileTreeIterator workTreeIterator!
            declare java.util.List diffEntries!
            declare Iterator diffIter!
            declare DiffEntry entry!
            declare RevWalk revWalk!
            declare CheckoutCommand checkoutCmd!

            repository!=#git!.getRepository()
            outputStream!=new ByteArrayOutputStream()

            REM Get a revcommit for the head of the repository
            declare ObjectId headObjectId!
            declare RevCommit headRevCommit!
            headObjectId!=repository!.resolve(Constants.HEAD)
            revWalk!=new RevWalk(repository!)
            headRevCommit!=revWalk!.parseCommit(headObjectId!)

            REM Get a list of diffs between the working tree and head commit
            formatter! = new DiffFormatter(outputStream!)
            formatter!.setRepository(repository!)
            commitTreeIterator! = #prepareTreeParser(headRevCommit!)
            workTreeIterator! = new FileTreeIterator(repository!)
            diffEntries! = formatter!.scan(commitTreeIterator!, workTreeIterator!)

            REM Process the diffs
            diffIter!=diffEntries!.iterator()

            declare BBjVector filesToCheckOut!
            filesToCheckOut!=BBjAPI().makeVector()

            while (diffIter!.hasNext())
                entry!=cast(DiffEntry,diffIter!.next())
                if !pos("DiffEntry[MODIFY"=entry!.toString()) then continue;rem --- shouldn't need to process ADDs
                formatter!.format(entry!)
                x$=outputStream!.toString()
                outputStream!.reset()

                declare BBjString fileName!
                fileName!=entry!.getNewPath()
                diffOnlyShowsLineEndings=#diffOnlyShowsLineEndings(x$)
                if (diffOnlyShowsLineEndings) then
                    REM Add the file to the list of files to check out.
                    filesToCheckOut!.add(entry!.getNewPath())
                endif
            wend

            if (filesToCheckOut!.size()>0) then
                checkOutCmd!=#git!.checkout()
                checkOutCmd!.addPaths(filesToCheckOut!)
                checkOutCmd!.call()

                if (! OwnerSetter.getOSIsWindows()) then
                    declare OwnerSetter setter!
                    setter!=new OwnerSetter()
                    setter!.setOwnerRecursively(#AonDir$)
                endif
            endif

        methodend        

        REM Prepare Tree Parser
        method protected CanonicalTreeParser prepareTreeParser(RevCommit commit!)
            declare RevWalk walk!
            declare Repository repository!
            declare ObjectId treeId!
            declare ObjectReader reader!

            repository!=#git!.getRepository()
            walk! = new RevWalk(repository!)
            treeId! = commit!.getTree().getId()
            reader! = repository!.newObjectReader()
            methodret new CanonicalTreeParser(null(), reader!, treeId!)
        methodend

        REM Called by filesWithDifferentLineEndings
        method public BBjNumber diffOnlyShowsLineEndings(BBjString diff!)

            REM The file should just have one big difference
            declare BBjString search!
            declare BBjString left!
            declare BBjString right!
            declare BBjNumber first!
            declare BBjNumber last!
            declare BBjNumber diffBegins!
            declare BBjNumber leftBegins!
            declare BBjNumber rightBegins!
            declare BBjNumber nextLineBegins!
            declare BBjNumber nextLineEnds!
            declare BBjString leftSide!
            declare BBjString rightSide!

            search!=$0A$+"@@"
            first!=diff!.indexOf(search!)
            last!=diff!.lastIndexOf(search!)

            if last!<>first! then methodret 0

            diffBegins!=last!
            leftDelimiter!=$0A$+"-"
            rightDelimiter!=$0A$+"+"

            leftSide!=#getSide(diff!,leftDelimiter!,diffBegins!)
            rightSide!=#getSide(diff!,rightDelimiter!,diffBegins!)

            methodret leftSide!=rightSide!
        methodend

        REM Called by diffOnlyShowsLineEndings
        method protected BBjString getSide(BBjString diff!, BBjString delimiter!, BBjNumber diffBegins!)
            declare BBjNumber begins!
            declare BBjNumber nextLineBegins!
            declare BBjString side!

            begins!=diff!.indexOf(delimiter!,diffBegins!)
            nextLineBegins!=begins!

            side!=""
            while (nextLineBegins!>0)
                nextLineEnds!=diff!.indexOf($0A$,nextLineBegins!+1)
                if (nextLineEnds!<0) then
                    nextLineEnds!=diff!.length()
                endif
                if (diff!.substring(nextLineEnds!-1,nextLineEnds!)=$0D$) then
                    nextLineEnds!=nextLineEnds!-1
                endif

                side!=side!+diff!.substring(nextLineBegins!+2,nextLineEnds!)

                nextLineBegins!=diff!.indexOf(delimiter!,nextLineBegins!+1)
           wend
           methodret side!
        methodend

        REM Method to look at a non-Git Addon install and figure out to what version it is closest.
        method public BBjNumber determineAndSwitchToVersion(BBjString ungitifiedAonDirName$)
            declare BBjString fixedIssuesFileName$
            declare BBjString version!
            declare java.util.Date date!
            declare java.util.List tagList!
            declare Iterator tagIter!
            declare Ref currentTag!
            declare BBjVector relevantTags!
            declare BBjString tagSearchString!
            declare RevCommit currentCommit!
            declare RevWalk walk!


            REM If we have FixedIssues.txt, use it to determine what version of Addon we should be using
            fixedIssuesFileName$=ungitifiedAonDirName$+"/documentation/FixedIssues.txt"

            #fixedIssuesReader!=new FixedIssuesReader()
            if (#fixedIssuesReader!.parse(fixedIssuesFileName$)) then
                version!=#fixedIssuesReader!.getVersion()
                fixedIssuesDate!=#fixedIssuesReader!.getDate()
            else
                throw "Could not find FixedIssues.txt file at "+fixedIssuesFileName$,12
            endif

            REM At this point, we need to check out the branch to create the "heads/<branch name> ref."
            branchName$="BBJ"+version!+"GA"
            branchString!="heads/"+branchName$
            #checkoutBranch(branchName$)

            REM Find the commit closest to the date
            tagList!=#git!.tagList().call()

            REM Get the tags that start with our release. Unfortunately, the stream() interface does
            REM not translate to BBj.
            tagIter!=tagList!.iterator()
            tagSearchString!="refs/tags/"+branchName$+"_"
            relevantTags!=BBjAPI().makeVector()

            REM Put the top of the branch on relevant tags list
            topOfBranch!=#git!.getRepository().findRef(branchString!)
            relevantTags!.add(topOfBranch!)

            REM Gather the relevant tags and put them in the relevant tags list
            chosenTag!=null()
            chosenTimeDifference!=Integer.MAX_VALUE
            while (tagIter!.hasNext())
                currentTag!=cast(Ref,tagIter!.next())

                if (currentTag!.getName().startsWith(tagSearchString!)) then
                    relevantTags!.add(currentTag!)
                endif
            wend

            REM Find the tag with the closest date to the release
            tagIter!=relevantTags!.iterator()
            walk!=new RevWalk(#git!.getRepository())
            while (tagIter!.hasNext())
                currentTag!=cast(Ref,tagIter!.next())
                currentCommit!=walk!.parseCommit(currentTag!.getObjectId())

                currentCommitTime!=currentCommit!.getCommitTime()
                fixedIssuesTime!=fixedIssuesDate!.getTime()/1000
                timeDifference!=currentCommitTime!-fixedIssuesTime!

                if (timeDifference!>-1) and (timeDifference!<chosenTimeDifference!) then
                      chosenTag!=currentCommit!
                      chosenTimeDifference!=timeDifference!
                endif
            wend

            REM If we found a closely matching tag, return it. Otherwise, return null.
            if (chosenTag!<>null()) then
                methodret #reset(chosenTag!)
            else
                methodret 0
            endif

        methodend

        method public void tagCurrentCommit(BBjString tagName!)
            if tagName!=null() then throw "tagName! can not be null!",17
            tagName!=tagName!.trim()
            if tagName!=$$ then throw "tagName! can not be blank!",17

            #git!.tag().setAnnotated(0).setName(tagName!).call()
        methodend

        REM Searches a file for a substring and returns 1 if the file contains the substring. Otherwise,
        REM returns 0. 
        method public BBjNumber fileContains(BBjString filePath$, BBjString regex$)
            declare Path fileToSearch!
            declare BBjString fileContent!
            declare Pattern pattern!
            declare Matcher matcher!
            
            pattern!=Pattern.compile(regex$)
        
            fileToSearch!=Paths.get(filePath$)
            fileContent!=Files.readString(fileToSearch!)
            matcher!=pattern.matcher(fileContent!)
            methodret matcher!.find()
        methodend 
classend

REM Parses the FixedIssues file and extracts the version and date from the file if successful
class public AO_FixedIssuesReader
    field public BBjString Version!=null()
    field public java.util.Date Date!=null()

    REM Constants
    field protected BBjString DATE_TOKEN!="Report Date:"
    field protected BBjString VERSION_TOKEN!="Report Branch: AddonSoftware "
    field protected BBjString DATE_FORMAT_STRING!="yyyy-MM-dd"

    method public BBjNumber parse(BBjString fixedIssuesFileName$)
        declare BBjNumber chan
        declare BBjNumber dateLineFound
        declare BBjNumber versionLineFound
        declare BBjNumber eof
        declare BBjString line$
        declare BBjString line!

        chan=unt
        open (chan) fixedIssuesFileName$

        dateLineFound=0
        versionLineFound=0
        while (!dateLineFound or !versionLineFound)
            read (chan,end=eof) line$
            line!=line$

            REM if the line has a date, assign it to dateLine
            if (line!.contains(#DATE_TOKEN!) and !dateLineFound) then
                dateLineFound=1
                dateLine!=line!
            endif

            REM if the line has a version assign it to versionLine
            if (line!.contains(#VERSION_TOKEN!) and !versionLineFound) then
                versionLineFound=1
                versionLine!=line!
            endif

            continue
        eof:
            REM --- when we've reached the end of the file, stop looping
            break
        wend
        close (chan)

        REM If we did not find our version and date, then return false here.
        if (!dateLineFound or !versionLineFound) then
            methodret 0
        endif

        REM Extract the date from the date line we read in
        dateLine!=dateLine!.substring(dateLine!.indexOf(#DATE_TOKEN!)+#DATE_TOKEN!.length())
        dateFormat!=new SimpleDateFormat(#DATE_FORMAT_STRING!)
        #Date!=cast(java.util.Date,dateFormat!.parse(dateLine!))

        REM Extract version from the version line we read in
        versionLine!=versionLine!.substring(versionLine!.indexOf(#VERSION_TOKEN!)+#VERSION_TOKEN!.length())
        version!=versionLine!.trim()
        periodNdx=version!.indexOf(".")
        #Version!=version!.substring(0,periodNdx)+version!.substring(periodNdx+1)

        methodret 1

    methodend
classend


REM Class to hold merge results
class public AO_MergeStatus
    
    field public ResolveMerger Merger!
    
    REM make default constructor uncallable
    method private AO_MergeStatus()
    methodend
    
    method public AO_MergeStatus(ResolveMerger merger!)
        if (merger!=null()) then 
            throw "Merger can not be null!",255
        endif 
        #Merger!=merger!
    methodend
    
    method public BBjNumber failed() 
        methodret #Merger!.failed()
    methodend 
    
    rem --- getMergeResults 
    rem  See https://archive.eclipse.org/jgit/site/5.6.0.201912101111-r/apidocs/org/eclipse/jgit/merge/ResolveMerger.html#getMergeResults--
    method public Map getMergeResults()
        methodret #Merger!.getMergeResults()
    methodend 
    
    rem --- getUnmergedPaths
    rem "Unmerged Paths" is otherwise known as "Files in a conflicted state."  This is going to give you your list of conflicted files and 
    rem with some additional processing, where the conflicts occur. 
    method public Map getUnmergedPaths()
        declare Map results!
        declare java.util.List filesWithConflicts!
        declare Iterator conflictIter!
        declare BBjString conflictedFile!
        declare MergeResult mergeResult!
        declare Map umergedPaths!
        
        results!=#getMergeResults()
        filesWithConflicts!=#Merger!.getUnmergedPaths()
        conflictIter!=filesWithConflicts!.iterator()
        unmergedPaths!=new TreeMap()
        while (conflictIter!.hasNext()) 
            conflictedFile!=cast(BBjString,conflictIter!.next())
            mergeResult!=cast(MergeResult,results!.get(conflictedFile!))
            unmergedPaths!.put(conflictedFile!,mergeResult!.getSequences().size())
        wend 
        methodret unmergedPaths!
    methodend  
    
classend 

class public SSH extends JschConfigSessionFactory implements TransportConfigCallback
    field private BBjString sshKey!
    field private BBjString password!=null()

    method public SSH(BBjString sshKey!)
        #sshKey!=sshKey!
    methodend

    method public SSH(BBjString sshKey!,BBjString password!)
        #this!(sshKey!)
        #password!=password!
    methodend

    method protected JSch createDefaultJSch( FS fs! )
        declare JSch defaultJSch!

        defaultJSch! = #super!.createDefaultJSch( fs! )
        if (#password!=null()) then
            defaultJSch!.addIdentity( #sshKey!)
        else
            defaultJsch!.addIdentity(#sshKey!,#password!)
        methodret defaultJSch!
    methodend

    method public void configure(Transport transport! )
        declare SshTransport sshTransport!
        sshTransport!= cast(SshTransport,transport!)
        sshTransport!.setSshSessionFactory(#this!)
    methodend

    method protected void configure(OpenSshConfig.Host host!,Session session!)
    methodend

classend

REM Visits all files and directories under a given topLevel directory and sets them as
REM owned by the specified user account.
class public Grepper extends SimpleFileVisitor

    field public BBjString Regex!
    field protected Pattern Pattern!
    
    field public BBjVector MatchingFiles!=BBjAPI().makeVector()
    
    method public static BBjVector grepRecursively(BBjString topLevelDirectory!, BBjString pattern!)
        declare Grepper grepper!
        grepper!=new Grepper(pattern!)
        Files.walkFileTree(Paths.get(topLevelDirectory!),grepper!)
        methodret grepper!.getMatchingFiles()
    methodend
    
    method public Grepper(BBjString pRegex$)
        #setRegex(pRegex$)
    methodend 
    
    method public void setRegex(BBjString pRegex$)
        #Regex!=pRegex$
        #Pattern!=Pattern.compile(#Regex!)
    methodend
    
    method public FileVisitResult preVisitDirectory(Object directory!, BasicFileAttributes attrs!)
        declare Path currentPath!
        currentPath!=cast(Path,directory!)
        if (currentPath!.getFileName().endsWith(".git")) then 
            methodret FileVisitResult.SKIP_SUBTREE
        endif 
        methodret FileVisitResult.CONTINUE
    methodend

    method public FileVisitResult visitFile(Object path!,BasicFileAttributes attr!)
        declare BufferedReader br!
        declare FileReader fr!
        declare Matcher matcher!
        
        path$ = cast(BBjString, path!.toString())
        if (path$ = null()) or pos("adx_upgradewiz"=path$) or pos("addonhelp.jar"=path$) or pos("aon"+File.separator+"documents"+File.separator=path$) then methodret FileVisitResult.CONTINUE
        fr! = new FileReader(path$)
        br! = new BufferedReader(fr!)
        if (br! = null()) then
            br! = Files.newBufferedReader(fr!,StandardCharsets.ISO_8859_1)
        endif
        if (br!.lines().anyMatch(#Pattern!.asPredicate(),err=*endif))
            #MatchingFiles!.add(path$)
        endif
        fr!.close()
        br!.close()
        methodret FileVisitResult.CONTINUE
    methodend
    
classend


REM Visits all files and directories under a given topLevel directory and sets them as
REM owned by the specified user account.
class public OwnerSetter extends SimpleFileVisitor

    field public static BBjNumber OSIsWindows!=(new String(info(0,0)).indexOf("Win"))>=0
    field public BBjString UserName!
    field protected UserPrincipal userPrincipal!

    method public OwnerSetter()
        #this!(java.lang.System.getProperty("user.name"))
    methodend

    method public OwnerSetter(BBjString userName!)
        #UserName!=userName!
        #userPrincipal!=FileSystems.getDefault().getUserPrincipalLookupService().lookupPrincipalByName(#UserName!)
    methodend

    method public void setOwnerRecursively(BBjString topLevelDirectory!)
        Files.walkFileTree(Paths.get(topLevelDirectory!),#this!)
    methodend

    method public FileVisitResult preVisitDirectory(Object directory!, BasicFileAttributes attrs!)
        #setUser(directory!)
        methodret FileVisitResult.CONTINUE
    methodend

    method public FileVisitResult visitFile(Object path!,BasicFileAttributes attr!)
        #setUser(path!)
        methodret FileVisitResult.CONTINUE
    methodend

    method public void setUser(Object path!)
        Files.setOwner(cast(Path,path!),#userPrincipal!)
    methodend
classend
