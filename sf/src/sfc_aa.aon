rem --- Schedule: Days Forecast Ahead/Behind (Public/Called)
rem --- Program sfc_aa v8.0.0 01Feb2008 (sfc_aa)
rem --- Created by c:\codeport_bbj\adx_codeport.bbj v1.1.5 (02/01/2008 12:45:16)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright (c) 1981-2007 AddonSoftware
rem --- All Rights Reserved

    seterr std_error
    setesc std_error
    enter wo_num$,v0$,v1$,method$,opcode_dev,status$

rem --- Retrieve the program path

    pgmdir$=stbl("+DIR_PGM",err=*next)
    status$="03"

rem --- Retrieve sysinfo data

    sysinfo_template$=stbl("+SYSINFO_TPL",err=*next)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=*next)
    milestone=num(stbl("+MILESTONE",err=*next),err=*next)
    firm_id$=sysinfo.firm_id$

rem --- Open/Lock files

    files=10,begfile=1,endfile=files
    dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
    files$[1]="IVS_PARAMS",ids$[1]="IVS_PARAMS"
    files$[3]="pom-01",ids$[3]="POM_CALENDAR"
    files$[4]="sfe-02",ids$[4]="SFE_WOOPRTN"
    files$[5]="sfe-03",ids$[5]="SFX_OPRTNWO"
    files$[6]="sfe-32",ids$[6]="SFE_WOSUBCNT"
    files$[7]="sfm-04",ids$[7]="SFM_OPCALNDR"
    files$[8]="sfm-05",ids$[8]="SFE_WOSCHDL"
    files$[9]="sfm-06",ids$[9]="SFX_WOSCHDXR"
    files$[10]="sfs-01a",ids$[10]="SFS_PARAMS"
    call pgmdir$+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],
:                                   ids$[all],templates$[all],channels[all],batch,status
    if status goto std_exit
    ivs01a_dev=channels[1]
    pom01a_dev=channels[3]
    sfe02a_dev=channels[4]
    sfe03d_dev=channels[5]
    sfe32a_dev=channels[6]
    sfm04a_dev=channels[7]
    sfm05a_dev=channels[8]
    sfm06a_dev=channels[9]
    sfs01a_dev=channels[10]

rem --- Dimension string templates

    dim ivs01a$:templates$[1],pom01a$:templates$[3],
:       sfe02a$:templates$[4],sfe03d$:templates$[5],sfe32a$:templates$[6],
:       sfm04a$:templates$[7],sfm05a$:templates$[8],sfm06a$:templates$[9],
:       sfs01a$:templates$[10]

rem --- Retrieve parameter records

    ivs01a_key$=firm_id$+"IV00"
    find record (ivs01a_dev,key=ivs01a_key$,err=std_missing_params) ivs01a$
    sfs01a_key$=firm_id$+"SF00"
    find record (sfs01a_dev,key=sfs01a_key$,err=std_missing_params) sfs01a$

rem --- Init Data

    v1$=v0$
    from_date$=v0$
    status$(2,1)="0"
    direction$=method$
    v$=v0$
    pass=1
    if len(v0$)=3 then let orig_date$=fnyy_yy21$(fndate$(fndate$(v0$))),v0_len=3 else let orig_date$=v0$,v0_len=6
    if method$="B" then let end_date$=orig_date$
    more=1

rem --- Retrieve key templates

    call stbl("+DIR_SYP")+"bac_key_template.bbj","SFX_WOSCHDXR","PRIMARY",sfm06a_key_tpl$,rd_table_chans$[all],status$
    call stbl("+DIR_SYP")+"bac_key_template.bbj","SFE_WOSUBCNT","PRIMARY",sfe32a_key_tpl$,rd_table_chans$[all],status$
    call stbl("+DIR_SYP")+"bac_key_template.bbj","SFE_WOOPRTN","PRIMARY",sfe02a_key_tpl$,rd_table_chans$[all],status$

rem --- Fix Data

    dim sfm06a_key$:sfm06a_key_tpl$
    dim sfe32a_key$:sfe32a_key_tpl$
    dim sfe02a_key$:sfe02a_key_tpl$
    dim daystat$[31]

    while more

        if len(v$)=3 then let v$=fnyy_yy21$(fndate$(fndate$(v$))),v1$=v$

    rem --- Check Validity of Data

        x$=""
        x0=0
        call pgmdir$+"adc_daydates.aon",v$,x$,x0
        if v$="N" then let status$(2,1)="2"; break
        if pos(direction$="BF")=0 then let status$(2,1)="4"; break

    rem --- Clear Schedule Detail Files

        read (sfm06_dev,key=firm_id$+wo_num$,dom=*next)

        while more
            sfm06a_key$=key(sfm06_dev,end=*break)
            if pos(firm_id$+wo_num$=sfm06a_key$)<>1 then break
            remove (sfm06_dev,key=sfm06a_key$)
            remove (sfm05_dev,key=sfm06a_key.firm_id$+sfm06a_key.op_code$+sfm06a_key.sched_date$+sfm06a_key.wo_no$+sfm06a_key.op_seq$,dom=*continue)
        wend

    rem --- Capture Subcontract Lead Time information

        if sfs01a.po_interface$="Y"
            read (sfe32_dev,key=firm_id$+"  "+wo_num$+"C",dom=*next)

        rem --- Read Loop

            while more
                sfe32a_key$=key(sfe32_dev,end=*break)
                if pos(firm_id$+"  "+wo_num$+"C"=sfe32a_key$)<>1 then break
                read record (sfe32_dev) sfe32a$
                if sfe32a.line_type$="S" then subs$=subs$+sfe32a.op_seq$+sfe32a.subcont_seq$+str(sfe32a.lead_time:"000")+"      "
            wend

        rem --- Set Required Date in Subcontracts for Forward method

            if direction$="F"
                f_yr=fnyy_year(v$(1,2))
                f_mth=num(v$(3,2)),f_day=num(v$(5,2)),occ=1
                
                while more
                    leadpos=pos("   "=subs$,15,occ)
                    if leadpos<>0
                        lead=num(subs$(leadpos+6,3))
                        while more
                            find record (pom01_dev,key=firm_id$+fnyear_yy21$(f_yr)+str(f_mth:"00"),dom=*break) pom01a$
                            for x=f_day to pom01a.days_in_mth
                                n=n+1
                                daystat$[n]=FIELD(pom01a$,"day_status_"+str(x:"00"))
                                if lead<=0 and daystat$[n]="W" then break
                                if daystat$[n]="W" then let lead=lead-1
                                f_day=f_day+1
                            next x

                            if lead<=0 and daystat$[n]="W" and f_day<=l0 then break
                            f_mth=f_mth+1
                            f_day=1
                            if f_mth>12 then let f_mth=1,f_yr=f_yr+1
                        wend

                    rem --- Save date for Subcontracts without op seq and try again

                        subs$(leadpos+9,6)=str(f_mth:"00")+str(f_day:"00")+fnyear_yy21$(f_yr)
                        v1$=fnyear_yy21$(f_yr)+str(f_mth:"00")+str(f_day:"00")
                        v$=v1$
                        occ=occ+1
                    endif
                wend

                status$(2,1)="5"
                break

            endif
        endif

    rem --- Get Operation record from woe-02

        first_time$="Y"
        if direction$="F" then read (sfe02_dev,key=firm_id$+"  "+wo_num$,dom=*next)
        if direction$<>"F" then read (sfe02_dev,key=firm_id$+"  "+wo_num$+"B",dom=*next)

    rem --- Get the record_id_* field of sfreq

    fields$=fattr(sfe02a_key_tpl$,"")
    f4$=fields$(pos($0A$=fields$)+1)
    f4$=f4$(1,pos($0A$=f4$)-1)

    rem --- Read Loop

    while more
        if direction$="F" then let sfe02a_key$=key(sfe02_dev,end=*break) else let sfe02a_key$=keyp(sfe02_dev,end=*break)
        if pos(firm_id$+"  "+wo_num$=sfe02a_key$)<>1 then break

        record_id_field$=field(sfe02a_key$,f4$,err=*break); rem value of record_id_* field
        if record_id_field$<>"A" then break
        gosub read_back
        if sfe02a.line_type$<>"M"
            op_code$= sfe02a.op_code$
            dim c[13]
            find record (opcode_dev,key=firm_id$+op_code$,dom=*next) opcode$
            v= sfe02a.total_time+ sfe02a.move_time+opcode.queue_time

        rem --- Calculate Date

            odate$=sfe02a.require_date$
            if direction$="F" v=opcode.queue_time,ele=0; if v>=0 gosub calc_fut_date

        rem "Checking for >=0 forces re-initialization required if all B[] vars here are zero.

            if direction$="F" then let v=sfe02a.setup_time,ele=1; if v>0 then gosub calc_fut_date_2
            if direction$="F" then let v=sfe02a.total_time-sfe02a.setup_time,ele=2; if v>0 then gosub calc_fut_date_2
            if direction$="F" then let v=sfe02a.move_time,ele=3; if v>0 then gosub calc_fut_date_1
            if direction$="B" then gosub calc_past_date
            v1$=fnyear_yy21$(f_yr)+str(f_mth:"00")+str(f_day:"00")
            v$=v1$
            if status$(2,1)<>"0" then break
            opnssort$=sfe02a.firm_id$+"D"+sfe02a.wo_location$+sfe02a.op_code$+odate$+sfe02a.wo_no$+sfe02a.op_seq$
            remove (sfe03_dev,key=opnssort$,dom=*next)

            opnssort$=sfe02a.firm_id$+"D"+sfe02a.wo_location$+sfe02a.op_code$+sfe02a.require_date$+sfe02a.wo_no$+sfe02a.op_seq$
            write record (sfe03_dev,key=opnssort$) sfe03d$
        endif
        write record (sfe02_dev,key=sfe02a_key$) sfe02a$
        if direction$="B" then gosub read_back
    wend

    rem --- Set Required Date in Subcontracts for Backward method

        if direction$="B"
            f_yr=fnyy_year(v$(1,2))
            f_mth=num(v$(3,2)),f_day=num(v$(5,2)),occ=1

            while more

                leadpos=pos("   "=subs$,-15,occ)
                if leadpos<>0
                    lead=num(subs$(leadpos+6,3))
                    
                    while more
                        find record (pom01_dev,key=firm_id$+fnyear_yy21$(f_yr)+str(f_mth:"00"),dom=*break) pom01a$
                        if f_day>=1
                            if f_day>l0 then let f_day=l0
                            n=0
                            for x=f_day to 1 step -1
                                n=n+1
                                daystat$[n]=FIELD(pom01a$,"day_status_"+str(x:"00"))
                                if lead<=0 and daystat$[n]="W" then break
                                if daystat$[n]="W" then let lead=lead-1
                                f_day=f_day+1
                            next x
                            if lead<=0 and f_day>0 then break
                        endif
                        f_mth=f_mth-1
                        f_day=31
                        if f_mth<1 then let f_mth=12,f_yr=f_yr-1
                    wend

                rem --- Save date for Subcontracts without op seq and try again

                    subs$(leadpos+9,6)=str(f_mth:"00")+str(f_day:"00")+fnyear_yy21$(f_yr)
                    v1$=fnyear_yy21$(f_yr)+str(f_mth:"00")+str(f_day:"00")
                    v$=v1$
                    occ=occ+1
                endif

            wend

            status$(2,1)="5"
            break

            endif

        endif

    rem --- Rewrite Subcontract records with operation sequences

        if sfs01a.po_interface$="Y"
            if !(len(subs$)=0 or direction$="B")
                for x=1 to len(subs$) step 15
                    extract record (sfe32_dev,key=firm_id$+"  "+wo_num$+"C"+subs$(x+3,3),dom=*continue) sfe32a$
                    if sfe32a.require_date$<>"   " and fndate$(subs$(x+9,6))<>sfe32a.require_date$ and pos(sfe32a$(52,1)="RP")>0 then let status$(1,1)="1"
                    sfe32a.require_date$=fndate$(subs$(x+9,6))
                    write record (sfe32_dev,key=firm_id$+"  "+wo_num$+"C"+subs$(x+3,3)) sfe32a$
                next x
            endif
        endif

    done: rem --- Done - Successful

        if len(v1$)=0 then let v1$=v0$
        if v0_len=3 then let v1$=fndate$(fndate$(v1$))
        if direction$="B" then let direction$="F",ret_date$=v1$,v$=v1$,used_hrs=0,subs$=""; continue
        if method$<>"F"
            if orig_date$<v$
                v0$=""
                call pgmdir$+"adc_daydates.aon",end_date$,v0$,-1
                direction$="B"
                v1$=v0$,v$=v0$,end_date$=v0$,pass=pass+1
                if pass>99 then let status$(2,1)="6"; goto std_exit
                if pass=2 then call pgmdir$+"syc_wa.bbx",0,12,3,35,18,"",pass_name$
                print @(1,0),'sb',"Pass: ",'sf',pass:"#0",
                continue
            endif
            v1$=ret_date$
        endif
        v0$=from_date$

    wend

rem --- Done - Unsuccessful

    goto std_exit

read_back: rem --- Read backwards allowing for different language platforms

    extract record (sfe02_dev,key=sfe02a_key$) sfe02a$
    return

calc_past_date: rem --- Calculate Past Date

    f_yr=fnyy_year(v$(1,2))
    f_mth=num(v$(3,2)),f_day=num(v$(5,2)),occ=1
    if sfs01a.po_interface$="Y"
        while more
            leadpos=pos(sfe02a.op_seq$=subs$,-15,occ)
            if leadpos=0 then break
            subs$(leadpos+9,6)=str(f_mth:"00")+str(f_day:"00")+fnyear_yy21$(f_yr)
            lead=num(subs$(leadpos+6,3))

            while more
                find record (pom01_dev,key=firm_id$+fnyear_yy21$(f_yr)+str(f_mth:"00"),dom=purdate_not_scehduled) pom01a$
                if f_day>l0 then let f_day=l0
                n=0
                for x=f_day to 1 step -1
                    n=n+1
                    daystat$[n]=FIELD(pom01a$,"day_status_"+str(x:"00"))
                    if lead<=0 and daystat$[n]="W" then break
                    if daystat$[n]="W" then let lead=lead-1
                    f_day=f_day-1
                next x
                f_mth=f_mth-1
                f_day=31
                if f_mth<1 then let f_mth=12,f_yr=f_yr-1
            wend

        rem --- Save Date for Subcontracts and try again

            occ=occ+1
        wend
    endif

rem --- Do Operations

    dim hrsperday[31]
    if sfs01a.po_interface$<>"M"

        while more
            find record (sfm04_dev,key=firm_id$+op_code$+fnyear_yy21$(f_yr)+str(f_mth:"00"),dom=opdate_not_scheduled) sfm04a$
            n=0
            for x=f_day to 1 step -1
                n=n+1
                hrsperday[n]=num(FIELD(sfm04a$,"hrs_per_day_"+str(x:"00")))
                if hrsperday[n]<0 then exitto opdate_not_scheduled
                if !(hrsperday[n]>0 and used_hrs>hrsperday[n])
                    if hrsperday[n]>0 then if used_hrs+v>=hrsperday[n] then let v=v-(hrsperday[n]-used_hrs),used_hrs=used_hrs+(hrsperday[n]-used_hrs) else let used_hrs=used_hrs+v,v=0
                endif
                if v<=0 then if hrsperday[n]>0 then let f_day=x; break
                used_hrs=0
            next x
            x$=""
            call pgmdir$+"adc_daydates.aon",fnyear_yy21$(f_yr)+str(f_mth:"00")+"01",x$,-1
            f_yr=fnyy_year(sfs01a.firm_id$)
            f_mth=num(sfs01a.wo$),f_day=num(sfs01a.sequence_00$)
        wend
        sfe02a.require_date$=fndate$(fndate$(v$))

    endif

    return

opdate_not_scheduled: rem --- Operation Date Not Scheduled

    status$(2,1)="1"
    return

purdate_not_scehduled: rem --- Purchase Date Not Scheduled

    status$(2,1)="5"
    return

calc_fut_date: rem --- Calculate Future Date

    f_yr=fnyy_year(v$(1,2))
    f_mth=num(v$(3,2)),f_day=num(v$(5,2)),occ=1

calc_fut_date_1:

    if sfe02a.line_type$<>"M"

    calc_fut_date_2:

        while more
            find record (sfm04_dev,key=firm_id$+op_code$+fnyear_yy21$(f_yr)+str(f_mth:"00"),dom=date_not_scheduled) sfm04a$
            if sfm04a.days_in_mth=0 then goto date_not_scheduled
            n=0
            for x=f_day to sfm04a.days_in_mth
                n=n+1
                hrsperday[n]=num(FIELD(sfm04a$,"hrs_per_day_"+str(x:"00")))
                if hrsperday[n]<0 then exitto date_not_scheduled
                if !(hrsperday[n]>0 and used_hrs>hrsperday[n])
                    if hrsperday[n]>0 then gosub wrt_scheduled_detail_files
                    if hrsperday[n]>0 then if used_hrs+v>=hrsperday[n] then let v=v-(hrsperday[n]-used_hrs),used_hrs=used_hrs+(hrsperday[n]-used_hrs) else let used_hrs=used_hrs+v,v=0
                endif
                sfe02a.require_date$=fndate$(fndate$(v$))
                if v<=0 then let f_day=x,sfe02a.require_date$=fndate$(str(f_mth:"00")+str(f_day:"00")+fnyear_yy21$(f_yr)); break
                used_hrs=0
                first_time$="N"
            next x
            f_mth=f_mth+1
            f_day=1
            if f_mth>12 then let f_yr=f_yr+1,f_mth=1
        wend

    endif

rem --- Do Subcontracts

    if !(sfs01a.po_interface$<>"Y" or ele<>3)
        while more
            leadpos=pos(sfe02a_key.op_seq$=subs$,15,occ)

            if leadpos<>0
                lead=num(subs$(leadpos+6,3))
                while more
                    find record (pom01_dev,key=firm_id$+fnyear_yy21$(f_yr)+str(f_mth:"00"),dom=purchdt_not_scheduled) pom01a$
                    for x=f_day to l0
                        n=n+1
                        daystat$[n]=FIELD(pom01a$,"day_status_"+str(x:"00"))
                        if lead<=0 and daystat$[n]="W" then break
                        if daystat$[n]="W" then let lead=lead-1
                        f_day=f_day+1
                    next x
                    if lead<=0 and daystat$[n]="W" and f_day<=l0 then break
                    f_mth=f_mth+1
                    f_day=1
                    if f_mth>12 then let f_mth=1,f_yr=f_yr+1
                wend

            rem --- Save Date for Subcontracts and try again

                subs$(leadpos+9,6)=str(f_mth:"00")+str(f_day:"00")+fnyear_yy21$(f_yr)
                occ=occ+1
            endif
        wend
    endif

    return

date_not_scheduled: rem --- Date Not Scheduled

    status$(2,1)="1"
    return

purchdt_not_scheduled: rem --- Purchase Date Not Scheduled

    status$(2,1)="5"
    return

wrt_scheduled_detail_files: rem --- Write Schedule Detail Files

    sfm05a_key$=firm_id$+op_code$+fndate$(str(f_mth:"00")+str(x:"00")+fnyear_yy21$(f_yr))+wo_num$+sfe02a.op_seq$
    if used_hrs+v>hrsperday[n] then let z=hrsperday[n]-used_hrs else let z=v
    extract record (sfm05_dev,key=sfm05a_key$,dom=*next) sfm05a$
    let w[ele]=w[ele]+z
    write record (sfm05_dev,key=sfm05a_key$) sfm05a$
    sfm06a_key$=sfm05a.firm_id$+sfm05a.wo_no$+sfm05a.op_seq$+sfm05a.op_code$+sfm05a.sched_date$
    write record (sfm06_dev,key=sfm06a_key$) sfm06a$
    return

rem #include std_functions.src
rem --- Standard AddonSoftware functions (01Mar2006)
rem --- Functions used to retrieve form values

    def fnstr_pos(q0$,q1$,q1)=int((pos(q0$=q1$,q1)+q1-1)/q1)
    def fnget_rec_date$(q0$)=rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                            cvs(q0$,1+2+4),rd_rec_data$[0,0],40),0]
    def fnget_fld_data$(q0$,q1$)=cvs(rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                                cvs(q1$,1+2+4),rd_rec_data$[0,0],40),0],2)
    def fnget_table$(q0$)=rd_alias_id$

rem --- Miscellaneous functions

    def fncenter(q$,q)=int((q-len(q$))/2)

rem --- Format inventory item description

    def fnitem$(q$,q1,q2,q3)=cvs(q$(1,q1)+" "+q$(q1+1,q2)+" "+q$(q1+q2+1,q3),32)

rem --- Format zip/postal code

    def fnzipcode$(q$)=fill(10,cvs(q$(1,3)+fill(pos("9"<q$(1,5))>0)+q$(4,2)+
:                      fill(ABS(pos("A">=q$(1,6))>0)-pos("0">q$(6,4))>0,"-")+
:                      q$(6,4)+fill(10),16))

rem --- Date/time handling functions

    def fndate$(q$)=date(jul(num(q$(1,4)),num(q$(5,2)),num(q$(7,2))))
    def fnyy$(q$)=q$(3,2)
    def fnclock$(q$)=date(0:"%hz:%mz %p")
    def fntime$(q$)=date(0:"%Hz%mz")

rem --- fnmask$: Alphanumeric Masking Function (formerly fnf$)

    def fnmask$(q1$,q2$)
        if q2$="" q2$=fill(len(q1$),"0")
        return str(-num(q1$,err=*next):q2$,err=*next)
        q=1
        q0=0
        while len(q2$(q))
              if pos(q2$(q,1)="-()") q0=q0+1 else q2$(q,1)="X"
              q=q+1
        wend
        if len(q1$)>len(q2$)-q0 q1$=q1$(1,len(q2$)-q0)
        return str(q1$:q2$)
    fnend

rem --- fnbasename$: Strip path and optionally the suffix from a file name

    def fnbasename$(q$,q0$)
        q=max(pos("/"=q$,-1),pos(":"=q$,-1),pos(">"=q$,-1),pos("\"=q$,-1))
        if q then q$=q$(q+1)
        if q0$<>"" then q=mask(q$,q0$); if q q$=q$(1,q-1)
    return q$

rem --- fnglobal: Return numeric value of passed stbl variable

    def fnglobal(q$,q1)
        q1$=stbl(q$,err=*next),q1=num(q1$,err=*next)
        return q1
    fnend

rem --- fnglobal$: Return string value of passed STBL variable

    def fnglobal$(q$,q1$)
        q1$=stbl(q$,err=*next)
        return q1$
    fnend

rem #endinclude std_functions.src

rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    call stbl("+DIR_SYP")+"bac_error.bbj",err=std_error_exit,pgm(-2),str(tcb(5):"00000"),
:                                str(err:"000"),rd_err_text$,rd_err_act$
    if pos("EXIT"=rd_err_act$) goto std_error_exit
    if pos("ESCAPE"=rd_err_act$) seterr 0;setesc 0
    if pos("RETRY"=rd_err_act$) retry
std_error_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_error_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_error_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_error.src
rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5):"00000"),
:                                   str(err:"000"),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_exit.src

std_exit: rem --- Standard called program exit (01Mar2006)

    exit
rem #endinclude std_exit.src

    end
