rem --- Work Order Material Issues Update
rem --- Program sfu_womatissu v8.0.0 22Mar2012 (wou_aa)
rem --- Created by Codeport Utility (03/22/2012 03:27:26)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright BASIS International Ltd.  All Rights Reserved.
rem --- All Rights Reserved

rem wgh ... modify for batching (see gdoc 13a,b,c,d)

    setesc std_error
    seterr std_error


	next_overlay$="";rem --- clear next_var and outvect! so adc_process_end doesn't loop...i.e., don't run anything after this
	OutVect!=null()

rem --- Retrieve the program path

	pgmdir$=stbl("+DIR_PGM",err=*next)

rem --- Retrieve sysinfo data

    dim sysinfo$:stbl("+SYSINFO_TPL")
    sysinfo$=stbl("+SYSINFO")
    firm_id$=sysinfo.firm_id$

rem --- Get user approval to update

    msg_id$="AON_UPDT_QUERY"
    dim x$:stbl("+SYSINFO_TPL")
    dim msg_tokens$[1]
    x$=stbl("+SYSINFO")                                                            
    msg_tokens$[1]=x.task_desc$
    gosub disp_message
    if msg_opt$<>"Y" then goto std_exit_no_update

rem --- Initialize inventory item update
	call stbl("+DIR_PGM")+"ivc_itemupdt.aon::init",ivfiles[all],ivs01a$,items$[all],refs$[all],refs[all],table_chans$[all],status
escape; rem wgh ... stop!!!
goto std_exit_no_update; rem wgh ... temporary exit for testing

rem --- Start progress meter and position header file

	call pgmdir$+"adc_progress.aon","NC","","","","",0,wotrans_dev,1,meter_num,status
    read (wotrans_dev,key=firm_id$,dom=*next)

rem --- Read next Issue Inventory Transaction (SFE_WOTRANS) record

    while 1
        read record (wotrans_dev,end=*break)wotrans$
        if wotrans.firm_id$<>firm_id$ then break
        call pgmdir$+"adc_progress.aon","S","","","","",0,0,1,meter_num,status

        rem --- Get Material Issues Header (SFE_WOMATISH, sfe-15) record for this transaction (and batch)
        sfe15_key$=firm_id$+batch_no$+wotrans.wo_location$+wotrans.wo_no$
        read record (sfe15_dev,key=sfe15_key$,knum="BATCH_KEY",dom=*continue) sfe15a$; rem --- skip if wrong batch

        rem --- Get Work Order Entry (SFE_WOMASTR, sfe-01) record
        dim sfe01a$:fattr(sfe01a$)
        find record (sfe01_dev,key=firm_id$+wotrans.wo_location$+wotrans.wo_no$,dom=*continue) sfe01a$
        if cvs(sfe01a.firm_id$,2)="" then
            rem --- SFE_WOMASTR (sfe-01) record not found
            remove (wotrans_dev,key=wotrans$,dom=+next)
            continue
        endif

        rem --- Process Material Issues Detail (SFE_WOMATISD, sfe-25) records
        read (sfe25_dev,key=sfe15_key$,knum="BATCH_KEY",dom=*next)
        while 1
            sfe25_key$=key(sfe25_dev,end=*break)
            if pos(sfe15_key$=sfe25_key$)<>1 then break
            read record (sfe25_dev) sfe25a$
            if sfe25a.qty_issued=0 then continue
            
            rem --- Update ivm-02 Warehouse Record
            updated_unit_cost=sfe25a.issue_cost
            if pos(p9$="LS")=0 or ivm01a.lotser_item$<>"Y" or ivm01a.inventoried$<>"Y" then
                gosub update_warehouse_record
            endif

rem wgh ... stopped here
            rem --- Update Open WO Material Transactions (SFT_OPNMATTR, sfe-21)
            dim sfe21a$:fattr(sfe21a$)
            sfe21a.firm_id$=sfe25a.firm_id$
            sfe21a.wo_location$=sfe25a.wo_location$
            sfe21a.wo_no$=sfe25a.wo_no$
            sfe21a.trans_date=sfe15a.issued_date$
            sfe21a.trans_seq$(1)=$ff$
            sfe21a.material_seq_ref$=sfe25a.internal_seq_no$
            sfe21a.unit_measure$=sfea25a.unit_measure$
            sfe21a.warehouse_id$=sfe25a.warehouse_id$
            sfe21a.item_id$=sfe25a.item_id$
            sfe21a.units=sfe25a.qty_issued
            sfe21a.unit_cost=updated_unit_cost
            precision 2
            sfe21a.ext_cost=sfe21a.units*sfe21a.unit_cost
            precision ivs01_precision
            next_seq_no=0
            sft21_key$=sfe21a.firm_id$=sfe25a.firm_id$+sfe21a.wo_location$=sfe25a.wo_location$+
:               sfe21a.wo_no$=sfe25a.wo_no$+sfe21a.trans_date=sfe15a.issued_date$+sfe21a.trans_seq$(1)=$ff$
            read (sft21_dev,key=sft21_key$,dom=*next)
            previous_key$=""
previous_key$=keyp(sft21_dev,end=*next)
if pos(y0$(1,15)=previous_key$)=1 next_seq_no=num(previous_key$(16,3),err=*next)+1
y0$(16,3)=str(next_seq_no:"000")
write record (sft21_dev,key=y0$) sft21a$
            
        wend
    wend

l1100: rem --- Main Read

    k0$=key(wotrans_dev,end=l4000)
    read (wotrans_dev)
    if k0$(1,5)<>firm_id$+"  "+"D" goto l4000
    read record (sfe15_dev,key=k0$(1,4)+k0$(6)+"000",dom=l1100) sfe15a$
    
l1220:
    dim d[11],z1$(g[4],"0"),d0$(30)
    find record (sfe01_dev,key=a0$(1,11),dom=l3900) sfe01a$
    find record (sfm10_dev,key=firm_id$+"A"+d0$(12,2),dom=*next) sfm10a$
    z1$=z1$(1,g[4])

    read (sfe25_dev,key=k0$(1,4)+k0$(6),dom=*next)
l1300: rem --- Process Issue Details

    k1$=key(sfe25_dev,end=l3000)
    if k1$(1,11)<>a0$(1,11) goto l3000
    dim w[4],b[10],c[16]
    read record (sfe25_dev,key=k1$) sfe25a$
    if w[3]=0 goto l1300
    call pgmdir$+"adc_progress.aon","S","","","",w0$(5,7)+"-"+w0$(12,3),0,0,1,0,ignore_status

rem --- Verify Inventory Item Number

    dim z0$(g[4],"0"),b1$(desc[1]+desc[2]+desc[3])
    find record (ivm01_dev,key=firm_id$+w1$(21,20),dom=l2900) ivm01a$
    find record (ivm02_dev,key=firm_id$+w1$(19,22),dom=l2900) ivm02a$
    v1=c[11]
    if r9$="N" z0$=b6$(1,g[4]); goto l1500
    read record (arm10_dev,key=firm_id$+"D"+c1$(13,2),dom=l1500) arm10d$
    z0$=ar1$(61,g[4])

l1500: rem --- Process LIFO/FIFO ?

    lifo$="N"
    if p3$(3,1)="N" or (pos(p9$="LS")>0 and b2$(19,2)="YY") goto l1600
rem --------------------------------------------------------------------------
rem It look like at some point this program was used both the estimate the
rem cost on registers (and use that cost for the GL) and to actually update
rem inventory.  This program current is used only for the first purpose.
rem ivc_itemupdt.aon is used to update all inventory and it has its own lifo/
rem fifo logic in it.  At some point, ivc_itemupdt should call this program
rem so that all lifo/fifo logic is in one place.
rem 
rem Since this program is currently always estimating the cost, not updating
rem it, lfchan_dev will always be ivw04_dev and we will always build the work
rem file if necessary.
rem
rem KJS 24-Dec-2008
rem --------------------------------------------------------------------------
    lifo$="Y"
    action$=p3$(3,1)+"I"
    quantity=abs(w[3])
    cost=w[4]
    type$="R"
    places=ivs01_precision
    lf_date$=a1$(7,3)
    if w[3]<0 action$(2,1)="R"
    dim item$[2]
    item$[0]=firm_id$
    item$[1]=w1$(19,2)
    item$[2]=w1$(21,20)
    call pgmdir$+"ivc_lifofifo.aon",action$,type$,lf_date$,lf_channels[all],lf_tmpls$[all],item$[all],places,quantity,cost,ret_cost,status
    v1=ret_cost

l1600: rem --- Update ivm-02 Warehouse Record

    if pos(p9$="LS")>0 and pos(b2$(19,2)="YY")=1 goto l1700
    gosub get_item_info
    refs[0]=-(w[3])
    refs[1]=v1
    gosub inventory_update

l1700: rem --- G/L Distribution

    precision 2
    if pos(lf$="LS")=0 goto l1760
    if pos(b2$(19,2)="YY")=0 goto l1760
    dim h[1]
    amount=0
    units=0
    read (sfe14_dev,key=w0$,dom=*next)
l1735:
    k1$=key(sfe14_dev,end=l1765)
    if pos(w0$=k1$)<>1 goto l1765
    read record (sfe14_dev,key=k1$) sfe14a$
    amount=amount+(-h[0]*h[1])
    units=units+(-h[0])
    goto l1735
l1760:
    amount=(-w[3])*w[4]
    units=-w[3]
l1765:
    account$=z0$
    v0$=account$
    when$=a1$(7,3)
    memo$=fnitem$(b1$,desc[1],desc[2],desc[3])
    ref1$="WO "+d0$(5,7)
    ref2$="Step "+w1$(7,3)
    ref3$="Whse "+d0$(54,2)
    if lifo$="Y" amount=(-w[3])*v1
    gosub glpost
    account$=z1$
    amount=-amount
    units=-units
    gosub glpost
    precision ivs01_precision

rem wgh ... stopped here
rem --- Open Work Order Transactions

    dim y0$(18),y1$(43),y[11]
    y0$(1)=w0$(1,11)+a1$(7,3)+"M"+$ff$
    y1$(1)=w0$(12,3)+w1$(1,2)
    y1$(22,22)=w1$(19,22)
    y[0]=w[3]
    y[1]=w[4]
    precision 2
    y[2]=w[3]*w[4]
    w9=0
    if lifo$="Y" y[2]=w[3]*v1
    precision ivs01_precision
    read (sft21_dev,key=y0$,dom=*next)
    l$=keyp(sft21_dev,end=l2010)
    if pos(y0$(1,15)=l$)=1 w9=num(l$(16,3),err=*next)+1
l2010:
    y0$(16,3)=str(w9:"000")
    write record (sft21_dev,key=y0$) sft21a$

rem --- Update WO Transaction Cross Reference

    dim m0$(18)
    m0$(1,11)=w0$(1,11)
    m0$(12,3)=a1$(7,3)
    m0$(15,1)="M"
    m0$(16,3)=y0$(16,3)
    write record (sfm07_dev,key=m0$) sfm07a$

rem --- Lotted/Serialized Update

    if pos(lf$="LS")=0 goto l2800
    if b2$(19,1)<>"Y" or b2$(20,1)<>"Y" goto l2800
    dim h[1],xf[11]
    read (sfe14_dev,key=w0$,dom=*next)
l2200:
    k1$=key(sfe14_dev,end=l2800)
    if pos(w0$=k1$)<>1 goto l2800
    read record (sfe14_dev,key=k1$) sfe14a$
    if h[0]=0 goto l2790
    gosub update_lotser_record

rem --- WOT-11 Here

    dim x[2],x0$(21)
    x0$(1)=y0$+$ff$
    x1$=" "
    x2$=h1$
    w9=0
    read (sft11_dev,key=x0$,dom=*next)
    l$=keyp(sft11_dev,end=l2450)
    if pos(y0$=l$)=1 w9=num(l$(19,3),err=*next)+1
l2450:
    x0$(19,3)=str(w9:"000")
    x[0]=h[0]
    x[1]=h[1]
    x[2]=x[0]*x[1]
    write record (sft11_dev,key=x0$) sft11a$

rem --- Done With Lot/Serial
l2790: remove (sfe14_dev,key=h0$)

    goto l2200

l2800: rem --- Check On More...

    w[1]=w[1]+w[3]
    w[3]=0
l2840:
    if w[1]>=w[0] goto l2880
    write record (sfe25_dev,key=w0$) sfe25a$
    r0$=w0$(1,11)+w1$(7,3)
    r1$=w1$(1,20+p[0])
    read record (sfe23_dev,key=r0$,dom=*next) woe23a$
    r0=w[0]
    r1=w[1]
    r2=w[2]
    r3=w[3]
    r4=w[4]
    write record (sfe23_dev,key=r0$) woe23a$
    goto l2890
l2880: remove (sfe25_dev,key=w0$,dom=*next)

remove (sfe23_dev,key=w0$(1,11)+w1$(7,3),dom=*next)

l2890:
    goto l1220

l2900: rem --- No Valid Item Code++

    w[3]=0
    goto l2840

l3000: rem --- Update Header

    extract record (sfe01_dev,key=a0$(1,11)) sfe01a$
    if pos(" "<>d0$(25,3))=0 d0$(25,3)=a1$(7,3)
    if d0$(28,3)<a1$(7,3) d0$(28,3)=a1$(7,3)
    write record (sfe01_dev,key=d0$(1,11)) sfe01a$

rem --- Any More Left?

    read (sfe25_dev,key=a0$(1,11),dom=*next)
    k4$=key(sfe25_dev,end=l3200)
    if k4$(1,11)<>a0$(1,11) goto l3200
    goto l3300
l3200: remove (sfe15_dev,key=a0$(1,11)+"000",dom=*next)

remove (sfe13_dev,key=a0$(1,11)+"000",dom=*next)

    goto l3900
l3300:
    a1$(7,3)=""
    write record (sfe15_dev,key=a0$) sfe15a$
    write record (sfe13_dev,key=a0$) woe13a$

l3900: rem --- Remove Record

remove (wotrans_dev,key=k0$,dom=l3990)

    goto l1100

l4000: rem --- End

    if gl$="Y" call pgmdir$+"glc_ctlupdate.aon",status
    call pgmdir$+"adc_batchdelete.aon",status
    goto l9900                                                  

UPDATE_WAREHOUSE_RECORD: rem --- Update Item/Warehouse Information 

    gosub get_item_info
    let refs[0]=-(w[3]),refs[1]=w[4]
    gosub inventory_update
    return                                                  

update_lotser_record: rem --- Update Lot/Serial Information 

    gosub get_item_info
    let items$[3]=h1$(1),refs[0]=-(h[0]),refs[1]=h[1]
    gosub inventory_update
    return                                                  
rem --- Inventory/Action Item Information
get_item_info:                                                  
    dim items$[3],refs$[11],refs[5]
    let items$[0]=w0$(1,2),items$[1]=w1$(19,2),items$[2]=w1$(21,20)
    let refs$[0]=a1$(7,3),refs$[3]=d0$(5,7),refs$[5]=w0$(12,3),action$="WI"
    let refs$[1]=d0$(34,6),refs$[2]=d0$(40,7),refs$[4]=d0$(12,2)
    let refs$[9]=d0$(56,20)
    return                                                  
rem --- Perform Inventory Update 
inventory_update:
    call pgmdir$+"ivc_itemupdt.aon",action$,ivfiles[all],ivs01a$,items$[all],refs$[all],refs[all],table_chans$[all],status
    return                                                  
rem --- Standard G/L Posting Routine
glpost:                                                  
    if gl$<>"Y" goto l6990
    call pgmdir$+"glc_glpost.aon",glm01_dev,glt04_dev,glt05_dev,account$,when$,ref1$,ref2$,ref3$,memo$,amount,units,status
l6990: return                                                  

rem #include std_functions.src
rem --- Standard AddonSoftware functions (01Mar2006)
rem --- Functions used to retrieve form values

    def fnstr_pos(q0$,q1$,q1)=int((pos(q0$=q1$,q1)+q1-1)/q1)
    def fnget_rec_date$(q0$)=rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                            cvs(q0$,1+2+4),rd_rec_data$[0,0],40),0]
    def fnget_fld_data$(q0$,q1$)=cvs(rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                                cvs(q1$,1+2+4),rd_rec_data$[0,0],40),0],2)
    def fnget_table$(q0$)=rd_alias_id$

rem --- Miscellaneous functions

    def fncenter(q$,q)=int((q-len(q$))/2)

rem --- Format inventory item description

    def fnitem$(q$,q1,q2,q3)=cvs(q$(1,q1)+" "+q$(q1+1,q2)+" "+q$(q1+q2+1,q3),32)

rem --- Format zip/postal code

    def fnzipcode$(q$)
        q$=cvs(q$,4)
        if len(cvs(q$,2))<>9 and len(cvs(q$,2))<>6 return q$
        if len(cvs(q$,2))=9
            q1$="[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]"
            q1=mask(cvs(q$,2),q1$)
            if q1=0 return q$
            if q1<>0
                if q$(6,4)="0000" return q$(1,5)
            return q$(1,5)+"-"+q$(6,4)
            endif
        endif
        if len(cvs(q$,2))=6
            q1$="[a-zA-Z][0-9][a-zA-Z][0-9][a-zA-Z][0-9]"
            q1=mask(cvs(q$,2),q1$)
            if q1=0 return q$ else return q$(1,3)+" "+q$(4,3)
        endif
    fnend

rem --- Date/time handling functions

    def fndate$(q$)
        q1$=""
        q1$=date(jul(num(q$(1,4)),num(q$(5,2)),num(q$(7,2)),err=*next),err=*next)
        if q1$="" q1$=q$
        return q1$
    fnend
    def fnyy$(q$)=q$(3,2)
    def fnclock$(q$)=date(0:"%hz:%mz %p")
    def fntime$(q$)=date(0:"%Hz%mz")

rem --- fnmask$: Alphanumeric Masking Function (formerly fnf$)

    def fnmask$(q1$,q2$)
        if q2$="" q2$=fill(len(q1$),"0")
        return str(-num(q1$,err=*next):q2$,err=*next)
        q=1
        q0=0
        while len(q2$(q))
              if pos(q2$(q,1)="-()") q0=q0+1 else q2$(q,1)="X"
              q=q+1
        wend
        if len(q1$)>len(q2$)-q0 q1$=q1$(1,len(q2$)-q0)
        return str(q1$:q2$)
    fnend

rem --- fnbasename$: Strip path and optionally the suffix from a file name

    def fnbasename$(q$,q0$)
        q=max(pos("/"=q$,-1),pos(":"=q$,-1),pos(">"=q$,-1),pos("\"=q$,-1))
        if q then q$=q$(q+1)
        if q0$<>"" then q=mask(q$,q0$); if q q$=q$(1,q-1)
    return q$

rem --- fnglobal: Return numeric value of passed stbl variable

    def fnglobal(q$,q1)
        q1$=stbl(q$,err=*next),q1=num(q1$,err=*next)
        return q1
    fnend

rem --- fnglobal$: Return string value of passed STBL variable

    def fnglobal$(q$,q1$)
        q1$=stbl(q$,err=*next)
        return q1$
    fnend

update_warehouse_record: rem --- Update Item/Warehouse Information 

    gosub get_item_info
    refs[0]=-(sfe25a.qty_issued)
    refs[1]=sfe25a.issue_cost
    gosub inventory_update
    return                                                  

update_lotser_record: rem --- Update Lot/Serial Information 

    gosub get_item_info
    let items$[3]=h1$(1),refs[0]=-(h[0]),refs[1]=h[1]
    gosub inventory_update
    return                                                  

get_item_info: rem --- Inventory/Action Item Information
    dim items$[3],refs$[11],refs[5]
    items$[0]=sfe25a.firm_id$,items$[1]=sfe25a.warehouse_id$,items$[2]=sfe25a.item_id$
    refs$[0]=sfe15a.issued_date$,refs$[1]=sfe01a.customer_id$,refs$[2]=sfe01a.order_no$
    refs$[3]=sfe01a.wo_no$,refs$[4]=sfe01a.wo_type$,refs$[5]=sfe25a.material_seq$
    refs$[9]=d0$(56,20)sfe01a.item_id$
    action$="WI"
    return                                                  

inventory_update: rem --- Perform Inventory Update 
    call pgmdir$+"ivc_itemupdt.aon",action$,ivfiles[all],ivs01a$,items$[all],refs$[all],refs[all],table_chans$[all],status
    updated_unit_cost=refs[1]
    return                                                  

disp_message: rem --- Display Message Dialog

    call stbl("+DIR_SYP")+"bac_message.bbj",msg_id$,msg_tokens$[all],msg_opt$,table_chans$[all]
    return

rem #endinclude std_functions.src

rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    call stbl("+DIR_SYP")+"bac_error.bbj",err=std_error_exit,pgm(-2),str(tcb(5)),
:       str(err),rd_err_text$,rd_err_act$
    if pos("EXIT"=rd_err_act$) goto std_error_exit
    if pos("ESCAPE"=rd_err_act$) seterr 0;setesc 0
    if pos("RETRY"=rd_err_act$) retry
std_error_exit: 
    master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_error_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_error_release: 
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_error.src

rem #include std_end.src

std_exit: rem --- Standard program end (01Mar2006)

    msg_id$="UPDATE_COMPLETE"
    dim msg_tokens$[1]
    msg_opt$=""
    gosub disp_message

std_exit_no_update: 

    if num(batch_no$)<>0
        unlock_key$=firm_id$+stbl("+PROCESS_ID")+stbl("+BATCH_NO")
        lock_status$=""
        call stbl("+DIR_SYP")+"bac_lock_record.bbj","ADM_PROCBATCHES",unlock_key$,"X","",rd_table_chan,rd_table_chans$[all],lock_status$
    endif
    call pgmdir$+"adc_progress.aon","D","","","","",0,0,0,meter_num,status
    run stbl("+DIR_SYP",err=*next)+"bas_process_end.bbj",err=*next
    release

rem #endinclude std_end.src

    end
