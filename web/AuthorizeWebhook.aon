CLASS PUBLIC AuthorizeWebhook

	use java.io.File

    use org.json.JSONObject
	
	use net.authorize.Environment
	use net.authorize.api.contract.v1.MerchantAuthenticationType
	use net.authorize.api.contract.v1.TransactionRequestType
	use net.authorize.api.contract.v1.SettingType
	use net.authorize.api.contract.v1.ArrayOfSetting
	use net.authorize.api.contract.v1.MessageTypeEnum
	use net.authorize.api.contract.v1.TransactionTypeEnum
	use net.authorize.api.contract.v1.GetHostedPaymentPageRequest
	use net.authorize.api.contract.v1.GetHostedPaymentPageResponse
	use net.authorize.api.contract.v1.GetTransactionDetailsRequest
	use net.authorize.api.contract.v1.OrderType
	use net.authorize.api.controller.base.ApiOperationBase
	use net.authorize.api.controller.GetHostedPaymentPageController
	use net.authorize.api.controller.GetTransactionDetailsController

	use ::ado_util.src::util	
	use ::ado_file.src::FileObject

    field private BBjspWebRequest request!
    field private BBjspWebResponse response!
    field private BBjspWebSession session!
    field private BBjspSessionData data!

    field private BBjInt logDev% = 0
    field private BBjInt adm_userroles% = 0
    field private BBjInt adm_user% = 0
    field private BBjInt ads_compinfo% = 0
    field private BBjInt adm_email_acct% = 0
    field private BBjInt adm_rptctl% = 0

    field private BBjString adm_userroles_tpl$ = ""
    field private BBjString adm_user_tpl$ = ""
    field private BBjString ads_compinfo_tpl$ = ""
    field private BBjString adm_email_acct_tpl$ = ""
    field private BBjString adm_rptctl_tpl$ = ""

  
    method public void service(BBjspServletContext context!)
	       
        #request! = context!.getRequest()
        #response! = context!.getResponse()

		content!=#request!.getBody()
		webhookInfo!=new JSONObject(content!)
		trans_id$=webhookInfo!.get("payload").get("id")

		rem --- These two lines put the trans_id$ in the namespace that is used by the internal (AR staff) payment form (from Customer master).
		rem --- If an internal payment form is up, the ACUS will get the namespace event and query the trans_id$ to see if the returned secure token
		rem --- corresponds to a payment from that form/session. If not, it's ignored.
		rem --- This lets us process both internal (AR staff) and external (customer payment) payments in this same servlet. 
		rem --- If this webhook *does* correspond to an internal payment, it should fall through and exit this servlet either because:
		rem ---    AUTHORIZEgw_config namespace variable isn't there (no customer payments made since BBj last started) or
		rem ---    AUTHORIZE+resp_id$ namespace variable isn't there (this webhook isn't associated with a customer payment)
		rem --- So the remainder of the code - posting the cash receipt and transaction response here in the servlet - only happens with external/customer payment.

		ns!=BBjAPI().getNamespace("aon","credit_receipt_authorize",1)
		ns!.setValue(trans_id$,content!)

		global_ns!=BBjAPI().getGlobalNamespace()
		gw_config!=new java.util.HashMap()
		gw_config!=global_ns!.getValue("AUTHORIZEgw_config",err=*next)
		if gw_config!.size()
			ApiOperationBase.setEnvironment(net.authorize.Environment.valueOf(gw_config!.get("environment")))

			merchantAuthenticationType!  = new MerchantAuthenticationType() 
			merchantAuthenticationType!.setName(gw_config!.get("name"))
			merchantAuthenticationType!.setTransactionKey(gw_config!.get("transactionKey"))
			ApiOperationBase.setMerchantAuthentication(merchantAuthenticationType!)

			getRequest! = new GetTransactionDetailsRequest()
			getRequest!.setMerchantAuthentication(merchantAuthenticationType!)
			getRequest!.setTransId(trans_id$)

			controller! = new GetTransactionDetailsController(getRequest!)
			controller!.execute()
			authResponse! = controller!.getApiResponse()

			if authResponse!.getMessages().getResultCode()=MessageTypeEnum.OK
				resp_cust$=authResponse!.getTransaction().getOrder().getInvoiceNumber()
				resp_sid$=authResponse!.getTransaction().getOrder().getDescription()
				resp_code=authResponse!.getTransaction().getResponseCode()
				payment_amt$=str(authResponse!.getTransaction().getAuthAmount())
				trans_msg$=authResponse!.getMessages().getMessage().get(0).getCode()+$0a$+authResponse!.getMessages().getMessage().get(0).getText()

				vectPymtInfo!=BBjAPI().makeVector()
				vectPymtInfo!=global_ns!.getValue("AUTHORIZE"+resp_sid$,err=*next)
				if vectPymtInfo!.size()
				
					wd$=vectPymtInfo!.get(0)
					user_id$=vectPymtInfo!.get(1)
					cust_id$=vectPymtInfo!.get(2)
					cash_rec_cd$=vectPymtInfo!.get(3)
					vectInvoices!=vectPymtInfo!.get(4)
					grid_cols=num(vectPymtInfo!.get(5))
					inv_pd_col=num(vectPymtInfo!.get(6))

					call stbl("+DIR_SYP")+"bas_process_beg.bbj",user_id$,rd_table_chans$[all]

					rem --- Retrieve sysinfo data

					sysinfo_template$=stbl("+SYSINFO_TPL",err=*next)
					dim sysinfo$:sysinfo_template$
					sysinfo$=stbl("+SYSINFO",err=*next)
					firm_id$=sysinfo.firm_id$

					rem --- Open files with adc

					files=6,begfile=1,endfile=files
					dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
					files$[1]="art_resphdr",ids$[1]="ART_RESPHDR"
					files$[2]="art_respdet",ids$[2]="ART_RESPDET"
					files$[3]="ars_cc_custpmt",ids$[3]="ARS_CC_CUSTPMT"
					files$[4]="are-01",ids$[4]="ARE_CASHHDR"
					files$[5]="are-11",ids$[5]="ARE_CASHDET"
					files$[6]="are-31",ids$[6]="ARE_CASHBAL"

					call stbl("+DIR_PGM")+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],ids$[all],templates$[all],channels[all],batch,status
					if status then
						seterr 0
						x$=stbl("+THROWN_ERR","TRUE")   
						throw "File open error.",1001
					endif
					
					art_resphdr = channels[1]
					art_respdet = channels[2]
					ars_cc_custpmt = channels[3]
					are_cashhdr = channels[4]
					are_cashdet = channels[5]
					are_cashbal = channels[6]

					dim art_resphdr$:templates$[1]
					dim art_respdet$:templates$[2]
					dim ars_cc_custpmt$:templates$[3]
					dim are_cashhdr$:templates$[4]
					dim are_cashdet$:templates$[5]
					dim are_cashbal$:templates$[6]
					
					readrecord(ars_cc_custpmt,key=firm_id$+cash_rec_cd$,dom=*next)ars_cc_custpmt$
					gateway_id$=ars_cc_custpmt.gateway_id$
					if resp_code
						batch_no$=ars_cc_custpmt.last_batch_no$
						deposit_id$=ars_cc_custpmt.last_deposit_id$

						redim are_cashhdr$

						are_cashhdr.firm_id$=firm_id$
						are_cashhdr.receipt_date$=date(0:"%Yd%Mz%Dz")
						are_cashhdr.customer_id$=cust_id$
						are_cashhdr.cash_rec_cd$=cash_rec_cd$

						receipt_found=0

						extractrecord(are_cashhdr,key=
:						are_cashhdr.firm_id$+
:						are_cashhdr.ar_type$+
:						are_cashhdr.reserved_key_01$+
:						are_cashhdr.receipt_date$+
:						are_cashhdr.customer_id$+
:						are_cashhdr.cash_rec_cd$+
:						are_cashhdr.ar_check_no$+
:						are_cashhdr.reserved_key_02$,dom=*next)are_cashhdr$;receipt_found=1
						if receipt_found
							if cvs(are_cashhdr.batch_no$,3)<>batch_no$ or cvs(are_cashhdr.deposit_id$,3)<>deposit_id$
								message!=BBjAPI().makeVector()
								message!.addItem("A cash receipt matching this customer, date and cash receipt code has already been entered")
								message!.addItem("using a different batch and/or deposit. You will need to MANUALLY adjust that cash receipt")
								message!.addItem("to reflect this credit card transaction.")
                                message!.addItem("are_cashhdr.receipt_date$="+are_cashhdr.receipt_date$)
                                message!.addItem("are_cashhdr.customer_id$="+are_cashhdr.customer_id$)
                                message!.addItem("are_cashhdr.cash_rec_cd$="+are_cashhdr.cash_rec_cd$)
                                message!.addItem("batch_no$="+batch_no$)
                                message!.addItem("deposit_id$="+deposit_id$)
								#logMessage(user_id$, message!, 1)
							endif
						endif

						are_cashhdr.payment_amt=are_cashhdr.payment_amt+num(payment_amt$)
						are_cashhdr.batch_no$=batch_no$
						are_cashhdr.deposit_id$=deposit_id$
						are_cashhdr$=field(are_cashhdr$)
						writerecord(are_cashhdr)are_cashhdr$
						rem --- now write are_cashdet and are_cashbal recs for each invoice in vectInvoices!
						for inv_row=0 to vectInvoices!.size()-1 step grid_cols
							pay_flag$=vectInvoices!.get(inv_row)
							if pay_flag$="Y"
								ar_inv_no$=vectInvoices!.get(inv_row+1)
								invoice_pay$=vectInvoices!.get(inv_row+inv_pd_col)
								invoice_disc$=vectInvoices!.get(inv_row+inv_pd_col-1)
								
								redim are_cashdet$
								redim are_cashbal$

								are_cashdet.firm_id$=firm_id$
								are_cashdet.receipt_date$=are_cashhdr.receipt_date$
								are_cashdet.customer_id$=are_cashhdr.customer_id$
								are_cashdet.cash_rec_cd$=are_cashhdr.cash_rec_cd$
								are_cashdet.ar_inv_no$=ar_inv_no$

								extractrecord(are_cashdet,key=
:								are_cashdet.firm_id$+
:								are_cashdet.ar_type$+
:								are_cashdet.reserved_key_01$+
:								are_cashdet.receipt_date$+
:								are_cashdet.customer_id$+
:								are_cashdet.cash_rec_cd$+
:								are_cashdet.ar_check_no$+
:								are_cashdet.reserved_key_02$+
:								are_cashdet.ar_inv_no$,dom=*next)are_cashdet$;rem advisory locking

								are_cashdet.apply_amt=are_cashdet.apply_amt+num(invoice_pay$)
								are_cashdet.discount_amt=are_cashdet.discount_amt+num(invoice_disc$)
								are_cashdet.batch_no$=are_cashhdr.batch_no$
								are_cashdet.memo_1024$=iff(cvs(are_cashdet.memo_1024$,3)="",invoice_cmt$,are_cashdet.memo_1024$+invoice_cmt$)
								are_cashdet.firm_id$=field(are_cashdet$)
								writerecord(are_cashdet)are_cashdet$
								are_cashbal.firm_id$=firm_id$
								are_cashbal.customer_id$=are_cashhdr.customer_id$
								are_cashbal.ar_inv_no$=ar_inv_no$

								extractrecord(are_cashbal,key=
:								are_cashbal.firm_id$+
:								are_cashbal.ar_type$+
:								are_cashbal.reserved_str$+
:								are_cashbal.customer_id$+
:								are_cashbal.ar_inv_no$,dom=*next)are_cashbal$

								are_cashbal.apply_amt=are_cashbal.apply_amt+num(invoice_pay$)
								are_cashbal$=field(are_cashbal$)
								writerecord(are_cashbal)are_cashbal$
							endif
						next inv_row
					endif
					rem --- write to response log
					if cvs(trans_id$,3)<>""
						response_text$=webhookInfo!.toString()
						trans_amount$=payment_amt$
						trans_approved$=iff(resp_code,"A","D");rem A=approved, D=declined

						rem --- get sequence number for response records
						call stbl("+DIR_SYP")+"bas_sequences.bbj","CREDIT_TRANS_NO",credit_trans_no$,rd_table_chans$[all],"QUIET"

						art_resphdr.firm_id$=firm_id$
						art_resphdr.credit_trans_no$=credit_trans_no$
						art_resphdr.customer_id$=cust_id$
						art_resphdr.transaction_id$=trans_id$
						art_resphdr.trans_type$="S";rem Sale
						art_resphdr.gateway_id$=gateway_id$
						art_resphdr.amount$=trans_amount$
						art_resphdr.approve_decline$=trans_approved$
						art_resphdr.response_text$=response_text$
						art_resphdr.created_user$=user_id$
						art_resphdr.created_date$=date(0:"%Yd%Mz%Dz")
						art_resphdr.created_time$=date(0:"%Hz%mz")
						art_resphdr.deposit_id$=deposit_id$
						art_resphdr.batch_no$=batch_no$
						art_resphdr$=field(art_resphdr$)
						writerecord(art_resphdr)art_resphdr$

						next_seq=1
						seq_mask$=fill(len(art_respdet.sequence_no$),"0")
						
						for inv_row=0 to vectInvoices!.size()-1 step grid_cols
							pay_flag$=vectInvoices!.get(inv_row)
							if pay_flag$="Y"
								ar_inv_no$=vectInvoices!.get(inv_row+1)
								invoice_pay$=vectInvoices!.get(inv_row+inv_pd_col)
								redim art_respdet$
								art_respdet.firm_id$=firm_id$
								art_respdet.credit_trans_no$=credit_trans_no$
								art_respdet.sequence_no$=str(next_seq:seq_mask$)
								art_respdet.customer_id$=cust_id$
								art_respdet.transaction_id$=trans_id$
								art_respdet.ar_inv_no$=ar_inv_no$;rem actual invoice selected or OAymmdd
								art_respdet.order_no$="";rem for future use by OP
								art_respdet.apply_amt$=invoice_pay$
								art_respdet$=field(art_respdet$)
								writerecord(art_respdet)art_respdet$
								next_seq=next_seq+1
							endif
						next inv_row
					endif
					global_ns!.removeValue("AUTHORIZEgw_config",err=*next)
					global_ns!.removeValue("AUTHORIZE"+resp_sid$,err=*next)
			else
				rem --- Unable to process GetTransactionDetailsRequest method.
				message!=BBjAPI().makeVector()
				message!.addItem("Unable to process GetTransactionDetailsRequest method.")
				message!.addItem("Request response code: "+authResponse!.getMessages().getResultCode())
                message!.addItem("Content: "+content!)
				#logMessage(user_id$, message!, 1)
			endif		
		endif

		goto end_logging;rem --- rem this line to enable output to .txt for troubleshooting

		response_path!=pgm(-2)
		response_path$=response_path!.replace("\","/")
		response_path$=response_path$(1,pos("/"=response_path$,-1,1))+"responselog/"
		mkdir response_path$,err=*next

		rspFile$=response_path$+"Authorize_webhook_response_"+str(int(tim*100000):"0000000")+".txt"
		erase rspFile$,err=*next
		string rspFile$
		rsp_chan=unt
		open(rsp_chan)rspFile$
		writerecord(rsp_chan)"Response file created..."+$0D0A$
		writerecord(rsp_chan)"Method is: "+#request!.getMethod()+$0D0A$
        
        if (#request!.getMethod()="POST") then 
            content!=#request!.getBody()
			writerecord(rsp_chan)"content is: "+content!
		else
			vectParamNames! = #request!.getParameterNames()
			if vectParamNames!.size()
				writerecord(rsp_chan)"Returned parameters..."+$0D0A$
				for wk=0 to vectParamNames!.size()-1
					writerecord(rsp_chan)vectParamNames!.get(wk)+$0D0A$
				next wk
			else
				writerecord(rsp_chan)"No params sent..."
				content!=#request!.getBody()
				writerecord(rsp_chan)"Body??"+$0D0A$
				writerecord(rsp_chan)content!
			endif
        endif 
		
		close(rsp_chan)

end_logging:

    METHODEND

    method private BBjInt getLogFile(BBjInt log_dev%)
		if log_dev%=0 then
			rem --- Get this installation's location
			num_files=1
			dim open_tables$[1:num_files],open_opts$[1:num_files],open_chans$[1:num_files],open_tpls$[1:num_files]
			table_alias$="DDM_SYSTEMS"
			open_tables$[1]=table_alias$,open_opts$[1]="OTA"
			call stbl("+DIR_SYP")+"bac_open_tables.bbj",
:           	open_beg,
:           	open_end,
:           	open_tables$[all],
:           	open_opts$[all],
:           	open_chans$[all],
:           	open_tpls$[all],
:           	table_chans$[all],
:           	open_batch,
:           	open_status$
			if open_status$<>"" then
				seterr 0
				x$=stbl("+THROWN_ERR","TRUE")   
				throw "AuthorizeWebhook: getLogFile(): Cannot open table: "+table_alias$,302
			endif

			ddm_systems=num(open_chans$[1])
			dim ddm_systems$:open_tpls$[1]

			readrecord(ddm_systems,key=pad("ADDON",16),knum="SYSTEM_ID")ddm_systems$
			location$=ddm_systems.mount_dir$

			rem --- Create logs directory at installation location
			logDir$ = FileObject.fixPath(location$ + "/logs", "/")
			FileObject.makeDirs(new File(logDir$))

			rem --- Create and/or open log file
			log$ = logDir$+"/online_ccpmt_issues.log"
			new_log=0
			string log$,err=*next; new_log=1
			log_dev%=int(unt)
			open(log_dev%)log$

			if new_log then
				rem --- Write header info for new log
				print(log_dev%)"Online Customer Credit Card Payment issues log started: " + date(0:"%Yd-%Mz-%Dz @ %Hz:%mz:%sz")
				print(log_dev%)
			else
				rem --- Move to end of existing log
				log_fin$=fin(log_dev%)
				log_size=dec($00$+log_fin$(1,4))
				read(log_dev%,ind=log_size,end=*next)
			endif
		endif

		methodret log_dev%
	methodend

    method private void logMessage(BBjString user_id$, BBjVector message!, BBjInt sendEmail%)
        #logDev%=#getLogFile(#logDev%)

        msgText$=date(0:"%Yd-%Mz-%Dz @ %Hz:%mz:%sz") + $0A$
        msgText$=msgText$+"AuthorizeWebhook" + $0A$
        msgText$=msgText$+"user: "+user_id$ + $0A$
		if message!.size()>0 then
			for i=0 to message!.size()-1
			    msgText$=msgText$+message!.getItem(i) + $0A$
			next i
		endif

		print(#logDev%)msgText$
        if sendEmail% then #sendCcOnlineEmail(msgText$)

		methodret
	methodend

    method private void sendCcOnlineEmail(BBjString msgText$)
        if #adm_userroles%=0 then
            num_files=5
            dim open_tables$[1:num_files],open_opts$[1:num_files],open_chans$[1:num_files],open_tpls$[1:num_files]
            open_tables$[1]="ADM_USERROLES",open_opts$[1]="OTA"
            open_tables$[2]="ADM_USER",open_opts$[2]="OTA"
            open_tables$[3]="ADS_COMPINFO",open_opts$[3]="OTA"
            open_tables$[4]="ADM_EMAIL_ACCT",open_opts$[4]="OTA"
            open_tables$[5]="ADM_RPTCTL",open_opts$[5]="OTA"
            call stbl("+DIR_SYP")+"bac_open_tables.bbj",
:               open_beg,
:               open_end,
:               open_tables$[all],
:               open_opts$[all],
:               open_chans$[all],
:               open_tpls$[all],
:               table_chans$[all],
:               open_batch,
:               open_status$
            if open_status$<>"" then
                seterr 0
                x$=stbl("+THROWN_ERR","TRUE")   
                throw "AuthorizeWebhook: sendCcOnlineEmail(): Cannot open table.",302
            endif

            #adm_userroles%=int(num(open_chans$[1]))
            #adm_user%=int(num(open_chans$[2]))
            #ads_compinfo%=int(num(open_chans$[3]))
            #adm_email_acct%=int(num(open_chans$[4]))
            #adm_rptctl%=int(num(open_chans$[5]))

            #adm_userroles_tpl$=open_tpls$[1]
            #adm_user_tpl$=open_tpls$[2]
            #ads_compinfo_tpl$=open_tpls$[3]
            #adm_email_acct_tpl$=open_tpls$[4]
            #adm_rptctl_tpl$=open_tpls$[5]
        endif

        dim adm_userroles$:#adm_userroles_tpl$
        dim adm_user$:#adm_user_tpl$
        dim ads_compinfo$:#ads_compinfo_tpl$
        dim adm_email_acct$:#adm_email_acct_tpl$
        dim adm_rptctl$:#adm_rptctl_tpl$

        rem --- Retrieve sysinfo data
        sysinfo_template$=stbl("+SYSINFO_TPL",err=*next)
        dim sysinfo$:sysinfo_template$
        sysinfo$=stbl("+SYSINFO",err=*next)
        firm_id$=sysinfo.firm_id$

        rem --- Get email address of users with CCONLINE security role
        userEmail!=BBjAPI().makeVector()
        adm_userroles.sec_role_id$="CCONLINE"
        read(#adm_userroles%,key=adm_userroles.sec_role_id$,knum="ROLE_USER",dom=*next)
        while 1
            readrecord(#adm_userroles%,end=*break)adm_userroles$
            if cvs(adm_userroles.sec_role_id$,2)<>"CCONLINE" then break
    
            redim adm_user$     
            readrecord(#adm_user%,key=adm_userroles.user_id$,dom=*next)adm_user$
            if cvs(adm_user.email_address$,2)<>"" then userEmail!.add(cvs(adm_user.email_address$,2))
        wend

        rem --- Get firm's email addresses
        firm_email_from$=""
        firm_email_replyto$=""
        readrecord(#ads_compinfo%,key=firm_id$,dom=*next)ads_compinfo$
        if cvs(ads_compinfo.email_account$,2)<>"" then
            readrecord(#adm_email_acct%,key=firm_id$+ads_compinfo.email_account$,dom=*endif)adm_email_acct$
            if cvs(adm_email_acct.firm_email_from$,2)<>"" then firm_email_from$=cvs(adm_email_acct.firm_email_from$,2)
            if cvs(adm_email_acct.firm_email_replyto$,2)<>"" then firm_email_replyto$=cvs(adm_email_acct.firm_email_replyto$,2)
        endif

        rem --- Get email account from Report Control
        adm_rptctl.dd_table_alias$="ARS_CC_CUSTPMT"
        readrecord(#adm_rptctl%,key=firm_id$+adm_rptctl.dd_table_alias$,dom=*next)adm_rptctl$
    
        rem --- Send message to email address for users with CCONLINE security role
        if userEmail!.size()=0 and firm_email_replyto$<>"" then userEmail!.add(adm_user.firm_email_replyto$)
        if userEmail!.size()>0 then
            for i=0 to userEmail!.size()-1
                thisEmail$=userEmail!.get(i)
            
                rem --- Make email entry in Doc Processing Queue
                docQueue! = new DocumentQueue()
                docQueue!.clear()
                docQueue!.setFirmID(firm_id$)
                docQueue!.setDocumentID("NOATTACH")
                docQueue!.setDocumentExt("PDF")
                docQueue!.setProcessType("E")
                docQueue!.setStatus("A");rem Auto-detect.  Queue will switch it to "Ready" if all required data is present
                docQueue!.setEmailAccount(cvs(adm_rptctl.email_account$,2))
                docQueue!.setEmailFrom(iff(firm_email_from$<>"", firm_email_from$, thisEmail$))
                docQueue!.setEmailTo(thisEmail$)
                docQueue!.setSubject("ERROR: AuthorizeWebhook")
                docQueue!.setMessage(msgText$)
                docQueue!.createProcess()
                proc_key$=docQueue!.getFirmID()+docQueue!.getProcessID()
                docQueue!.checkStatus(proc_key$)
            next i
        endif

        methodret
    methodend
    
CLASSEND