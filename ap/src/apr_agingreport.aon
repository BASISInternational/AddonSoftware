rem --- Aging Report (Report Overlay)
rem --- Program apr_cashrequire v8.0.0 01Feb2007 (apr_cb)
rem --- Created by adx_codeport.bbx v1.1.5 (02/01/2007 01:10:36)

rem --- AddonSoftware Version 8.0.0 - 01Jan2007
rem --- Copyright (c) 1981-2007 AddonSoftware
rem --- All Rights Reserved

    setesc std_error
    seterr std_error

rem --- Retrieve the program path

    pgmdir$=stbl("+DIR_PGM",err=*next)

rem --- Retrieve sysinfo data

    sysinfo_template$=stbl("+SYSINFO_TPL",err=*next)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=*next)
    milestone=num(stbl("+MILESTONE",err=*next),err=*next)
    firm_id$=sysinfo.firm_id$

rem --- Open/Lock files

    files=7,begfile=1,endfile=files
    dim files$[files],options$[files],ids$[files],templates$[files],channels[files]
    files$[1]="ads-01"
    files$[2]="apm-01"
    files$[3]="apm-03"
    files$[4]="apm-10"
    files$[5]="apt-01"
    files$[6]="apt-11"
    files$[7]="apw-02"
    options$[7]="C"
    call pgmdir$+"adc_fileopen.aon",action,begfile,endfile,files$[all],options$[all],
:                                   ids$[all],templates$[all],channels[all],batch,status
    if status goto std_exit
    ads01_dev=channels[1]
    apm01_dev=channels[2]
    apm03_dev=channels[3]
    apm10_dev=channels[4]
    apt01_dev=channels[5]
    apt11_dev=channels[6]
    apw02_dev=channels[7]

rem --- Dimension string templates

    dim apm01a$:templates$[2],apm03a$:templates$[3],apm10a$:templates$[4],
:       apt01a$:templates$[5],apt11a$:templates$[6],apw02a$:templates$[7]

rem --- Retrieve miscellaneous templates

    files=2,begfile=1,endfile=files
    dim ids$[files],templates$[files]
    ids$[1]="aps-01A"
    ids$[2]="gls-01A"
    call pgmdir$+"adc_template.aon",begfile,endfile,ids$[all],templates$[all],status
    if status goto std_exit

rem --- Dimension miscellaneous string templates

    dim aps01a$:templates$[1],gls01a$:templates$[2]

rem --- Assign form input values to local variables

    table$=fnget_table$("")
    agingdate$=fnget_fld_data$(table$,"aging_date")
    option$=fnget_fld_data$(table$,"report_option")
    future$=fnget_fld_data$(table$,"pick_check_1")
    sequence$=fnget_fld_data$(table$,"report_sequence")
    level$=fnget_fld_data$(table$,"report_summ_det")
    method$=fnget_fld_data$(table$,"report_type")
    days$=fnget_fld_data$(table$,"pick_integer")
    discounts$=fnget_fld_data$(table$,"pick_check_2")
    days=num(days$,err=*next)
    method=pos(method$="PD")
    sorting=sequence$="A"
    detail=level$="D"
    summary=level$="S"
    include=future$="Y"
    discounts=discounts$="Y"

rem --- Retrieve parameter records

    aps01a_key$=firm_id$+"AP00"
    find record (ads01_dev,key=aps01a_key$,err=std_missing_params) aps01a$
    gls01a_key$=firm_id$+"GL00"
    find record (ads01_dev,key=gls01a_key$,err=std_missing_params) gls01a$
    vendor_size=num(aps01a.vendor_size$)
    multitypes=aps01a.multi_types$="Y"
    retention=aps01a.ret_flag$="Y"
    apperiod=num(aps01a.current_per$)
    m0$=aps01a.vendor_output$
    m1$=aps01a.amount_mask$
    call pgmdir$+"adc_sizemask.aon",m1$,m1,9,13
    m0=len(m0$)
    m1=len(m1$)
    periodend$=""
    maxperiods=num(gls01a.total_pers$)
    for x=1 to maxperiods
        periodend$=periodend$+field(gls01a$,"per_ending_"+str(x:"00"))
    next x

rem --- Initializations

    dim headings$[8],o[12]
    dim pt[4],pr[4],rt[4],rr[4],at[4],ar[4],vt[3],vr[4],it[2]
    done=0
    page=0
    width=132
    offset=1
    headings=6
    maxlines=59
    lines=maxlines+1
    moreheaders=1
    moredetail=1
    byperiod=1
    bydays=2
    nf$="(Not On File)"
    m5$="###-###-####"
    lasttype$=""
    lastvendor$=""
    clock$=""
    when$=sysinfo.system_date$
    header2$="All Activity Based On "
    if option$="I" header2$=header2$+"Invoice Date"
    if option$="D" header2$=header2$+"Due Date"
    if option$="A" header2$=header2$+"Accounting Date"
    if detail header1$="Detail "+sysinfo.task_desc$
    if summary header1$="Summary "+sysinfo.task_desc$
    if detail and discounts header2$=header2$+" With Discounts"
    headings$[0]=sysinfo.firm_name$
    headings$[2]=header2$
    if multitypes
       headings=7
       offset=2
    endif
    if sequence$="V"
       channel=apt01_dev
       headings$[1]=header1$+" By Vendor Number"
    endif
    if sequence$="A" 
       channel=apw02_dev
       headings$[1]=header1$+" By Alternate Sequence"
    endif

rem --- Determine period beginning and ending dates based on the aging method selected

    switch method

           rem --- By period

           case byperiod

                rem --- Determine which period the aging date falls into

                year=num(agingdate$(1,4))
                mmdd$=agingdate$(5,4)
                for x=1 to maxperiods
                    period=x
                    if mmdd$>periodend$((x*4)-3,4) continue
                    if x=1 if mmdd$>periodend$((maxperiods*4)-1,4) break
                    if x>1 if mmdd$>periodend$(((x-1)*4)-3,4) break
                    if x=1 if periodend$((x*4)-3,4)<periodend$(maxperiods*4-3,4) break
                    if x>1 if periodend$((x*4)-3,4)<periodend$((x-1)*4-3,4) break
                next x

                rem --- Get current period beginning and ending dates

                if agingdate$(5,2)<periodend$(1,2) year=year-1
                call pgmdir$+"adc_perioddates.aon",ads01_dev,period,year,
:                                                  begperiod$,endperiod$,status
                begdates$=begperiod$
                enddates$=endperiod$

                rem --- Calculate prior period beginning and ending dates

                base=period
                for x=1 to 3
                    period=base-x
                    if period<1
                       period=maxperiods+period
                       year=year-1
                    endif
                    call pgmdir$+"adc_perioddates.aon",ads01_dev,period,year,
:                                                      begperiod$,endperiod$,status
                    begdates$=begdates$+begperiod$
                    enddates$=enddates$+endperiod$
                next x
           break

           rem --- By days

           case bydays
                begdates$=""
                enddates$=""
                for x=0 to 3
                    newdate$=""
                    difference=(-days)*(x+1)-1
                    call pgmdir$+"adc_daydates.aon",agingdate$,newdate$,difference
                    begdates$=begdates$+newdate$
                    newdate$=""
                    difference=(-days)*x
                    call pgmdir$+"adc_daydates.aon",agingdate$,newdate$,difference
                    enddates$=enddates$+newdate$
                next x
           break

           case default
           break

    swend

rem --- Define print positions

    o[12]=width-m1
    o[0]=0
    o[1]=o[0]+m0+1
    for x=11 to 7 step -1
        o[x]=o[x+1]-m1
    next x
    if summary
       for x=2 to 6
           o[x]=o[7]
       next x
       if sequence$="A"
          o[1]=o[0]+m0+12
       endif
       w=o[7]-1
    endif
    if detail
       o[6]=o[7]-2
       o[5]=o[6]-3
       o[4]=o[5]-9
       o[3]=o[4]-11
       o[2]=o[3]-11
       o[1]=11
       w=o[3]-1
    endif

rem --- Initialize remaining report headings

    dim header1$(width),header2$(width),header3$(width),underline$(6*m1,"-")
    retention$="Retention"
    for x=0 to 3
        p=o[8+x]+1+m1-9
        if x<>3 header1$(p,8)=fndate$(begdates$((x*8)+1,8))
        header2$(p,7)="Through"
        header3$(p,8)=fndate$(enddates$((x*8)+1,8))
    next x
    header1$(p,8)="First"
    header3$(1,6)="Vendor"
    header3$(o[7]+1+m1-7,6)="Future"
    header3$(o[12]+1+m1-6,5)="Total"
    if detail
       header2$(o[4]+3,5)="Aging"
       header3$(o[2]+1,9)="Reference"
       header3$(o[3]+1,7)="Invoice"
       header3$(o[4]+3,4)="Date"
       header3$(o[5]+1,2)="PG"
       header3$(o[6]+1,1)="H"
    endif
    headings$[3+offset]=header1$
    headings$[4+offset]=header2$
    headings$[5+offset]=header3$
    if summary headings=headings+1

rem --- Open printer

    call pgmdir$+"adc_printer.aon",printer_dev,1,"","",status
    if status goto std_exit

rem --- Sort Invoice Headers (apt-01) by vendor alternate sequence

    while sorting
          call pgmdir$+"adc_progress.aon","NC","","","","",0,apt01_dev,1,meter_num,status
          read (apt01_dev,key=firm_id$,dom=*next)

          rem --- Read next invoice record

          while moreheaders
                k$=key(apt01_dev,end=*break)
                if pos(firm_id$=k$)<>1 break
                read record (apt01_dev) apt01a$
                call pgmdir$+"adc_progress.aon","S","","","","",0,0,1,meter_num,status

                rem --- Retrieve vendor master record if necessary

                if pos("TEMP"=apt01a.vendor_id$)=1
                   lastvendor$=apt01a.vendor_id$
                   apm01a.alt_sequence$=apt01a.vendor_id$
                endif
                if lastvendor$<>apt01a.vendor_id$
                   dim apm01a$:fattr(apm01a$)
                   lastvendor$=apt01a.vendor_id$
                   apm01a.firm_id$=apt01a.firm_id$
                   apm01a.vendor_id$=apt01a.vendor_id$
                   k$=apm01a.firm_id$+apm01a.vendor_id$
                   find record (apm01_dev,key=k$,dom=*proceed) apm01a$
                endif
 
                rem --- Write sort record

                dim apw02a$:fattr(apw02a$)
                apw02a.firm_id$=apt01a.firm_id$
                apw02a.ap_type$=apt01a.ap_type$
                apw02a.alt_sequence$=apm01a.alt_sequence$
                apw02a.vendor_id$=apt01a.vendor_id$
                apw02a.ap_inv_no$=apt01a.ap_inv_no$
                apw02a.sequence_00$=apt01a.sequence_00$
                k$=apw02a.firm_id$+apw02a.ap_type$+apw02a.alt_sequence$+apw02a.vendor_id$+
:                  apw02a.ap_inv_no$+apw02a.sequence_00$
                write record (apw02_dev,key=k$) apw02a$

               rem --- Loop back for next record

          wend

          rem --- Sorting completed

          call pgmdir$+"adc_progress.aon","D","","","","",0,0,0,0,status
          sorting=0
          break
    wend  

rem --- Start progress meter and position driver file

    lastvendor$=""
    call pgmdir$+"adc_progress.aon","NC","","","","",0,channel,1,meter_num,status
    read (channel,key=firm_id$,dom=*next)

rem --- Read next Invoice Header (apt-01) record

    while moreheaders
          k$=key(channel,end=*break)
          if pos(firm_id$=k$)<>1 break
          if sequence$="A"
             read record (apw02_dev,key=k$) apw02a$
             apt01a.firm_id$=apw02a.firm_id$
             apt01a.ap_type$=apw02a.ap_type$
             apt01a.vendor_id$=apw02a.vendor_id$
             apt01a.ap_inv_no$=apw02a.ap_inv_no$
             apt01a.sequence_00$=apw02a.sequence_00$
             k$=apt01a.firm_id$+apt01a.ap_type$+apt01a.vendor_id$+
:               apt01a.ap_inv_no$+apt01a.sequence_00$
          endif
          read record (apt01_dev,key=k$,dom=*continue) apt01a$
          call pgmdir$+"adc_progress.aon","S","","","","",0,0,1,meter_num,status

          rem --- Level breaks

          if apt01a.ap_type$<>lasttype$ gosub type_break
          if apt01a.vendor_id$<>lastvendor$ gosub vendor_break

          rem --- Initializations for this invoice

          dim it[2]
          it[0]=apt01a.invoice_amt
          it[1]=apt01a.discount_amt
          it[2]=apt01a.retention
          future=apt01a.invoice_amt
          invoice$=apt01a.firm_id$+apt01a.ap_type$+apt01a.vendor_id$+
:                  apt01a.ap_inv_no$

          rem --- Position Invoice Detail (apt-11) file

          read (apt11_dev,key=invoice$,dom=*next)

          rem --- Calculate invoice totals by including any detail transactions

          while moredetail
                k$=key(apt11_dev,end=*break)
                if pos(invoice$=k$)<>1 break
                read record (apt11_dev) apt11a$
                if cvs(apt11a.trans_type$,2)="" continue
                if include=0 if apt11a.trans_date$>agingdate$ continue
                it[0]=it[0]+apt11a.trans_amt
                it[1]=it[1]+apt11a.trans_disc
                it[2]=it[2]+apt11a.trans_ret
          wend

          rem --- Assign the chosen date for aging purposes

          if option$="I" dateused$=apt01a.invoice_date$
          if option$="A" dateused$=apt01a.accting_date$
          while option$="D"
                dateused$=apt01a.inv_due_date$
                if discounts=0 break
                if apt01a.disc_date$>=agingdate$ and apt01a.disc_date$<>apt01a.invoice_date$ 
                   dateused$=apt01a.disc_date$
                   it[0]=it[0]-it[1]
                endif
                break
          wend

          rem --- Age this invoice

          if include=0 if dateused$>agingdate$ if (it[0]=future or detail) continue
          if include=0 if dateused$>agingdate$ it[0]=it[0]-future

          rem --- No reason to continue if it's a sero balance invoice

          if it[0]=0 continue

          rem --- Age this invoice

          printed=printed+1
          period=pos(dateused$>enddates$,8)
          if period=0 period=4 
:                else period=int(period/8)

          rem --- Accumulate totals

          vt[period]=vt[period]+it[0]
          at[period]=at[period]+it[0]
          rt[period]=rt[period]+it[0]
          ar[period]=ar[period]+it[2]
          rr[period]=rr[period]+it[2]

          rem --- Print invoice if this is a detail report

          if summary continue
          while vendor$<>""
                if lines+3>maxlines gosub report_heading
                print (printer_dev) ""
                print (printer_dev) @(o[0]),vendor$
                lines=lines+2
                vendor$=""
          wend
          if lines+1>maxlines gosub report_heading
          print (printer_dev) @(o[1]),phone$,@(o[2]),apt01a.reference$,@(o[3]),apt01a.ap_inv_no$,
:                             @(o[4]),fndate$(dateused$),@(o[5]),apt01a.payment_grp$,
:                             @(o[6]),apt01a.hold_flag$,@(o[7+period]),it[0]:m1$,@(o[12]),it[0]:m1$
          lines=lines+1
          phone$=""

          rem --- Loop back for next record

    wend

rem --- All done

    done=1
    gosub type_break
    total$="Totals For Report"
    for x=0 to 4
        pt[x]=rt[x]
        pr[x]=rr[x]
    next x
    gosub print_total
    goto std_exit

report_heading: rem --- Report Heading

    lines=headings+1
    call pgmdir$+"adc_rpthead.aon",printer_dev,headings$[all],headings,page,width,when$,clock$,status
    if status exitto std_exit
    return

print_total: rem --- Print totals

    totamt=0
    totret=0
    for x=0 to 4
        totamt=totamt+pt[x]
        totret=totret+pr[x]
    next x
    if lines+(2+retention)>maxlines gosub report_heading
    print (printer_dev) @(o[7]),underline$
    print (printer_dev) @(o[7]-len(total$)-1),total$,@(o[7]),pt[0]:m1$,@(o[8]),pt[1]:m1$,@(o[9]),pt[2]:m1$,
:                       @(o[10]),pt[3]:m1$,@(o[11]),pt[4]:m1$,@(o[12]),totamt:m1$
    if retention print (printer_dev) @(o[7]-len(retention$)),total$,@(o[7]),pt[0]:m1$,@(o[8]),pt[1]:m1$,
:                                    @(o[9]),pt[2]:m1$,@(o[10]),pt[3]:m1$,@(o[11]),pt[4]:m1$,@(o[12]),totamt:m1$
    lines=lines+(2+retention)
    return

type_break: rem --- AP Type break

    while lasttype$<>""
          gosub vendor_break
          if multitypes
             total$="Totals for "+aptype$
             for x=0 to 4
                 pt[x]=at[x]
                 pr[x]=ar[x]
             next x
             gosub print_total
          endif
          break
    wend
    if multitypes=0 return
    if done return
    dim apm10a$:fattr(apm10a$),at[4],ar[4]
    apm10a.firm_id$=apt01a.firm_id$
    apm10a.record_id_a$="A"
    apm10a.ap_type$=apt01a.ap_type$
    apm10a.code_desc$=nf$
    k$=apm10a.firm_id$+apm10a.record_id_a$+apm10a.ap_type$
    find record (apm10_dev,key=k$,dom=*next) apm10a$
    lasttype$=apm10a.ap_type$
    aptype$="AP Type "+apm10a.ap_type$+" "+cvs(apm10a.code_desc$,2)
    headings$[3]=aptype$
    lines=maxlines+1
    return

vendor_break: rem --- Vendor break

    while lastvendor$<>""
          if detail
             if printed>1
                total$="Totals for Vendor "+vendorid$
                for x=0 to 4
                    pt[x]=vt[x]
                    pr[x]=vr[x]
                next x
                flag=retention
                retention=0
                gosub print_total
                retention=flag
             endif
          endif
          if summary
             if printed
                if lines+2>maxlines
                   gosub report_heading
                endif
                totamt=0
                for x=0 to 4
                    totamt=totamt+vt[x]
                next x
                print (printer_dev) @(o[0]),vendor$,@(o[7]),vt[0]:m1$,@(o[8]),vt[1]:m1$,@(o[9]),vt[2]:m1$,
:                                   @(o[10]),vt[3]:m1$,@(o[11]),vt[4]:m1$,@(o[12]),totamt:m1$
                lines=lines+2
             endif
          endif
          break
    wend
    if done return
    dim vendor$(w),vt[4],vr[4]
    lastvendor$=apt01a.vendor_id$
    altseq$=""
    printed=0
    if pos("TEMP"=apt01a.vendor_id$)<>1
       dim apm01a$:fattr(apm01a$)
       apm01a.firm_id$=apt01a.firm_id$
       apm01a.vendor_id$=apt01a.vendor_id$
       apm01a.vendor_name$=nf$
       k$=apm01a.firm_id$+apm01a.vendor_id$
       find record (apm01_dev,key=k$,dom=*proceed) apm01a$
       if sequence$="A"
          altseq$=apm01a.alt_sequence$+" "
       endif
       phone$=fnmask$(apm01a.phone_no$,m5$)
       vendorid$=fnmask$(apm01a.vendor_id$(1,vendor_size),m0$)
       vendor$(1)=altseq$+vendorid$+" "+apm01a.vendor_name$
    endif
    if pos("TEMP"=apt01a.vendor_id$)=1
       dim apm03a$:fattr(apm03a$)
       apm03a.firm_id$=apt01a.firm_id$
       apm03a.ap_type$=apt01a.ap_type$
       apm03a.ap_inv_no$=apt01a.ap_inv_no$
       apm03a.vendor_name$=nf$
       k$=apm03a.firm_id$+apm03a.ap_type$+apm03a.ap_inv_no$
       find record (apm03_dev,key=k$,dom=*proceed) apm03a$
       vendorid$=apt01a.vendor_id$
       vendor$(1)=altseq$+apt01a.vendor_id$+" "+apm03a.vendor_name$
    endif
    return

rem --- Functions

rem --- Functions used to retrieve form values

    def fnstr_pos(q0$,q1$,q1)=int((pos(q0$=q1$,q1)+q1-1)/q1)
    def fnget_rec_date$(q0$)=rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                            cvs(q0$,1+2+4),rd_rec_data$[0,0],40),0]
    def fnget_fld_data$(q0$,q1$)=cvs(rd_rec_data$[fnstr_pos(cvs(q0$,1+2+4)+"."+
:                                cvs(q1$,1+2+4),rd_rec_data$[0,0],40),0],2)
    def fnget_table$(q0$)=rd_alias_id$

rem --- Date/time handling functions

    def fndate$(q$)=date(jul(num(q$(1,4)),num(q$(5,2)),num(q$(7,2))))

rem --- fnmask$: Alphanumeric Masking Function (formerly fnf$)

    def fnmask$(q1$,q2$)
        if q2$="" q2$=fill(len(q1$),"0")
        return str(-num(q1$,err=*next):q2$,err=*next)
        q=1
        q0=0
        while len(q2$(q))
              if pos(q2$(q,1)="-()") q0=q0+1 else q2$(q,1)="X"
              q=q+1
        wend
        if len(q1$)>len(q2$)-q0 q1$=q1$(1,len(q2$)-q0)
        return str(q1$:q2$)
    fnend

rem #include std_error.src

std_error: rem --- Standard error handler (01Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_error_exit)
    call pgmdir$+"adc_error.aon",err=std_error_exit,pgm(-2),str(tcb(5):"00000"),
:                                str(err:"000"),rd_err_text$,rd_err_act$
    if pos("EXIT"=rd_err_act$) goto std_error_exit
    if pos("ESCAPE"=rd_err_act$) seterr 0;setesc 0
    if pos("RETRY"=rd_err_act$) retry
std_error_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_error_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_error_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_error_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_error_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_error.src

rem #include std_missing_params.src

std_missing_params: rem --- Standard missing parameter handler (15Apr2006)

    rd_err_text$=""
    if tcb(5)<>0 and pgm(-1)=pgm(-2) rd_err_text$=pgm(tcb(5))
    pgmdir$=stbl("+DIR_PGM",err=std_missing_params_exit)
    call pgmdir$+"adc_noparams.aon",err=std_missing_params_exit,pgm(-2),str(tcb(5):"00000"),
:                                   str(err:"000"),rd_err_text$,rd_err_act$
std_missing_params_exit:
    master_user$=cvs(stbl("+MASTER_USER",err=std_missing_params_release),2)
    sysinfo_template$=stbl("+SYSINFO_TPL",err=std_missing_params_release)
    dim sysinfo$:sysinfo_template$
    sysinfo$=stbl("+SYSINFO",err=std_missing_params_release)
    if cvs(sysinfo.user_id$,2)=master_user$ escape
std_missing_params_release:
    status=999
    if pgm(-1)<>pgm(-2) exit
    release

rem #endinclude std_missing_params.src

rem #include std_end.src

std_exit: rem --- Standard program end (01Mar2006)

    run pgmdir$+"ads_process_end.aon",err=*next
    release

rem #endinclude std_end.src

    end
